<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指offer系列----item32 把数组排成最小数</title>
      <link href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E6%95%B0/"/>
      <url>/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>把数组变成String的list，然后两个两个比较，因为s1+s2的长度和s2+s1的长度是一致的，所以如果s1+s2与s2+s1的大小判断只需要判从首个字符开始即可（所以调用的String类的compareTo方法），如果s1+s2&gt;s2+s1,OK，那么说明s2应该在s1的前面，具体代码见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cc:numbers)&#123;</span><br><span class="line">            list.add(String.valueOf(cc));</span><br><span class="line">        &#125;</span><br><span class="line">        list.sort((S1,S2) -&gt; (S1+S2).compareTo(S2+S1));<span class="comment">//核心lambda表达式，具体可以去参考我的另外一篇博客</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(String ll:list)&#123;</span><br><span class="line">            sb.append(ll);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Lamdba表达式，可以看我的另外一篇博客：<a href="https://blog.csdn.net/weixin_38107316/article/details/105918971" target="_blank" rel="noopener">Lambda表达式</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item31 从1到n个整数中，包含1的个数有几个？</title>
      <link href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item31-%E4%BB%8E1%E5%88%B0n%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%AD%EF%BC%8C%E5%8C%85%E5%90%AB1%E7%9A%84%E4%B8%AA%E6%95%B0%E6%9C%89%E5%87%A0%E4%B8%AA%EF%BC%9F/"/>
      <url>/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item31-%E4%BB%8E1%E5%88%B0n%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%AD%EF%BC%8C%E5%8C%85%E5%90%AB1%E7%9A%84%E4%B8%AA%E6%95%B0%E6%9C%89%E5%87%A0%E4%B8%AA%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>如题所示，从1到n个整数中，包含1的个数有几个？</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这道题最最直接的思路应该是数学解答方法，即利用纯数学归纳总结出结果。但是有点儿复杂，且容易错。本文中采用递归法，对问题进行解答。首先给出代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> dfs(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String numStr = String.valueOf(n);<span class="comment">//利用字符串将数字剥离，利用数学方法还需循环</span></span><br><span class="line">        <span class="keyword">int</span> high = numStr.charAt(<span class="number">0</span>) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> pow = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, numStr.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> last = n - high * pow;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (high == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 最高位是1，如1234, 此时pow = 1000,那么结果由以下三部分构成：</span></span><br><span class="line">            <span class="comment">// (1) dfs(pow - 1)代表[0,999]中1的个数;</span></span><br><span class="line">            <span class="comment">// (2) dfs(last)代表234中1出现的个数;</span></span><br><span class="line">            <span class="comment">// (3) last+1代表固定高位是1有多少种情况。</span></span><br><span class="line">            <span class="keyword">return</span> dfs(pow - <span class="number">1</span>) + dfs(last) + last + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 最高位不为1，如2234，那么结果也分成以下三部分构成：</span></span><br><span class="line">            <span class="comment">// (1) pow代表固定高位1，有多少种情况;</span></span><br><span class="line">            <span class="comment">// (2) high * dfs(pow - 1)代表999以内和1999以内低三位1出现的个数;</span></span><br><span class="line">            <span class="comment">// (3) dfs(last)同上。</span></span><br><span class="line">            <span class="keyword">return</span> pow + high * dfs(pow - <span class="number">1</span>) + dfs(last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>明显看到，这种解法将问题分成了两大核心模块：<br>1.首位为1；2.首位非1。然后再进一步解答~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item30 一个数组的最大连续子序列之和</title>
      <link href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item30-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E4%B9%8B%E5%92%8C/"/>
      <url>/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item30-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>输入一个数组，输出这个数组的最大连续子序列之和。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>思路有2，第一种传统的动态规划思路。这种可以划分为多个子问题叠加的题目利用动态规划解决是最最经典的思路。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[]=<span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    dp[<span class="number">0</span>]= array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max=array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        dp[i]=Math.max(dp[i-<span class="number">1</span>]+array[i],array[i]);<span class="comment">//转移方程</span></span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;max)&#123;</span><br><span class="line">            max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，可以利用贪心算法进行求解：<br>数组的每个数字挨个相加，但是需要注意规则：<br>当num小于等于0时，将num改为当前数组nums[i]的值；<br>当num大于0时，num=num+nums[i]的值；<br>不断对比max和num的值，返回最大值max。<br>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                num = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                num += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;num)&#123;</span><br><span class="line">                max=num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item29 一个数组中最小的K个数</title>
      <link href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item29-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item29-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>如题所示，输出一个数组中最小的k个数。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这道题思路其实很简单，核心就是去排序，所以这道题实际考察的是排序的求解思路。具体见以下三种做法：</p><p>利用封装的sort函数（懒人法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(input);</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(k&gt;input.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        list.add(input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用快排切分的思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个参数表示我们要找的是下标为k-1的数</span></span><br><span class="line">        <span class="keyword">return</span> quickSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] quickSearch(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(nums, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j &gt; k? quickSearch(nums, lo, j - <span class="number">1</span>, k): quickSearch(nums, j + <span class="number">1</span>, hi, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[lo];</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= hi &amp;&amp; nums[i] &lt; v);</span><br><span class="line">            <span class="keyword">while</span> (--j &gt;= lo &amp;&amp; nums[j] &gt; v);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t = nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[lo] = nums[j];</span><br><span class="line">        nums[j] = v;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用堆排序的思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：</span></span><br><span class="line"><span class="comment">// 1. 若目前堆的大小小于K，将当前数字放入堆中。</span></span><br><span class="line"><span class="comment">// 2. 否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；</span></span><br><span class="line"><span class="comment">//    反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认是小根堆，实现大根堆需要重写一下比较器。</span></span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k) &#123;</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; pq.peek()) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回堆中的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[pq.size()];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: pq) &#123;</span><br><span class="line">            res[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item28 数组中超过一半的数</title>
      <link href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item28-%E6%95%B0%E7%BB%84%E4%B8%AD%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0/"/>
      <url>/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item28-%E6%95%B0%E7%BB%84%E4%B8%AD%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>思路有2：<br>其一，首先对数组进行排序，然后再利用动态规划解决问题；<br>其二，直接利用摩尔投票法进行问题的解决。</p><p>具体解法见下：<br>way1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。</span></span><br><span class="line"><span class="comment">由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：因为只有一个数字出现的次数大于数组的一半，那么就可以直接将整个数组中出现最多的这个数给找出来，</span></span><br><span class="line"><span class="comment">如出现的次数大于数组长度的一半，返回该数字。反之，返回0即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">具体思路：先排序数组，然后利用动态规划的思想</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">item26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];<span class="comment">//dp[i]为插入第i个数字之后第i个数字出现的频率；</span></span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        dp[<span class="number">0</span>]= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxindex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)y&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==array[i-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;sum)&#123;</span><br><span class="line">                sum=dp[i];</span><br><span class="line">                maxindex=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;array.length/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//System.out.println(sum);</span></span><br><span class="line">            <span class="keyword">return</span> array[maxindex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>way2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, votes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(votes == <span class="number">0</span>) x = num;</span><br><span class="line">            votes += num == x ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种思想应该着重记一下，蛮有趣的~ 与君共勉！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>看懂Lambda表达式这一篇就够了</title>
      <link href="/2020/05/04/%E7%9C%8B%E6%87%82Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
      <url>/2020/05/04/%E7%9C%8B%E6%87%82Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<hr><p>author：Siriustjq</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>关于lambda表达式，网上的资料不少，但是仔细看一看就会发现，写的良莠不齐，且大部分博文的表达较差，词不达意，所以这里自己进行一次总结，方便日后复习。</p><h2 id="什么是Lambda表达式？"><a href="#什么是Lambda表达式？" class="headerlink" title="什么是Lambda表达式？"></a>什么是Lambda表达式？</h2><p>lambda表达式，是Java作为面向对象的编程语言在函数式编程方面的一些拓展和优点合并。<br><strong>Lambda 允许把函数（行为）作为一个方法的参数（函数作为参数传递进方法中）</strong>。在lambda表达式子出现之前，实现这种功能大部分时候是在依赖匿名内部类。而lambda表达式利用lambda操作符“-&gt;”实现了很多以前必须要匿名内部类才能实现的功能，并且极大地简化了代码的结构和复杂度。</p><p>lambda操作符将整个lambda表达式分为了两部分，即箭头的左右：<br><strong>箭头左边表示lambda表达式的参数列表；<br>箭头右边则具体表示lambda表达式所要执行的功能，或者说是函数体。</strong><br>这里提前说明，lambda表达式是离不开接口的。见下面这个例子：</p><p>多线程大家一定不陌生，创建一个线程无非有两种方法（不考虑线程池）：1.继承Thread类；2.实现Runable接口。实际的生产实践中自然是使用第二种方法更多，因为一个类只能有一个父类，但是却可以实现多个接口。那么下面使用第二种方法新建一个线程并且采用匿名内部类的方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"传统匿名内部类的实现方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，代码量还是蛮大的，当然比去实现一个Runable接口要简洁的多得多，如果想进一步简洁代码呢？那就用到了lambda表达式了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">"lambda表达式的实现方法"</span>)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test();</span><br><span class="line">test1();</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果如下：</span></span><br><span class="line">传统匿名内部类的实现方法</span><br><span class="line">lambda表达式的实现方法</span><br></pre></td></tr></table></figure><p>可以看到短短一条语句就完全替换了之前的匿名内部类，效率确实有一些高~<br>通过这个例子，能更好的理解lambda表达式离不开接口。通过上面例子可以大致看出lambda表达式的一些端倪了，让我们来总结一下：<br><strong>-&gt;lambda表达式的左边为形参，注意形参一定要和lambda表达式所关联的接口的抽象方法的形参保持一致，不然会报错！</strong>这里很多博文的总结一直有问题，所以重申一下。<br>-&gt;lambda表达式的右边为方法的重写，谁的方法？自然也就是lambda表达式所关联接口的方法的重写，在这里你可以为所欲为的调用其他类的方法进行重写，<strong>但是一定要注意返回值务必要和原生的接口方法的返回值一致</strong>。针对以上两点，有一句很绕的官方解释：<strong>“实现抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致”</strong>。建议还是按照我的解释来理解容易一些。</p><p>一个例子可能还是太空洞了，请看下面这个例子，让集合list按照我们所制定的规则进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.sort((s1,s2)-&gt;(s1+s2).compareTo(s2+s1));</span><br></pre></td></tr></table></figure><p>乍一看这一句会云里雾里，我们来看看list集合的sort方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);<span class="comment">//调用的是Arrays.sort()方法</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显调用的是Arrays.sort()方法，我们继续深入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sort(a, fromIndex, toIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, fromIndex, toIndex, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, fromIndex, toIndex, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续进入legacyMergeSort方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">legacyMergeSort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    T[] aux = copyOfRange(a, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">if</span> (c==<span class="keyword">null</span>)</span><br><span class="line">        mergeSort(aux, a, fromIndex, toIndex, -fromIndex);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mergeSort(aux, a, fromIndex, toIndex, -fromIndex, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续深入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Object[] src,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Object[] dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> off,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Comparator c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = high - low;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insertion sort on smallest arrays</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;high; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;low &amp;&amp; c.compare(dest[j-<span class="number">1</span>], dest[j])&gt;<span class="number">0</span>; j—)<span class="comment">//终于逮到你了</span></span><br><span class="line">                swap(dest, j, j-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively sort halves of dest into src</span></span><br><span class="line">    <span class="keyword">int</span> destLow  = low;</span><br><span class="line">    <span class="keyword">int</span> destHigh = high;</span><br><span class="line">    low  += off;</span><br><span class="line">    high += off;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(dest, src, low, mid, -off, c);</span><br><span class="line">    mergeSort(dest, src, mid, high, -off, c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If list is already sorted, just copy from src to dest.  This is an</span></span><br><span class="line">    <span class="comment">// optimization that results in faster sorts for nearly ordered lists.</span></span><br><span class="line">    <span class="keyword">if</span> (c.compare(src[mid-<span class="number">1</span>], src[mid]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">       System.arraycopy(src, low, dest, destLow, length);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge sorted halves (now in src) into dest</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= <span class="number">0</span>)</span><br><span class="line">            dest[i] = src[p++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dest[i] = src[q++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于我们发现在这里会调用Comparator内的方法compare方法，而我们已经将其按照我们所需要实现的逻辑进行了重写，也就是在lambda表达式的右边的式子：(s1+s2).compareTo(s2+s1)；<br>在理解了上面lambda表达式的逻辑之后，马上我们可以再利用传统的匿名内部类对上述代码重构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list.sort(<span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String)o1+(String)o2).compareTo((String)o2+(String)o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>二者实现的功能完全一致，均能让集合list按照我们所指定的逻辑进行排序。</p><h2 id="写在最后："><a href="#写在最后：" class="headerlink" title="写在最后："></a>写在最后：</h2><p>一句话总结lambda表达式———它可以让我们更简便更直接的去实现一个接口，并重写其方法。</p><h2 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h2><p>本篇博客主要是以分析lambda的含义与典型作用方法为主，具体的表达式语法可参考：<a href="https://www.runoob.com/java/java8-lambda-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/java/java8-lambda-expressions.html</a><br> <a href="https://www.cnblogs.com/nnxud/p/9827704.html" target="_blank" rel="noopener">https://www.cnblogs.com/nnxud/p/9827704.html</a><br> 以上两篇博客说的都比较详细了，这里记录一下也方便自己日后及时查看复习。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item27 字符串的排列（究极无敌多种java回溯+剪枝做法）</title>
      <link href="/2020/04/29/%E5%89%91%E6%8C%87offer-item27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%88%E7%A9%B6%E6%9E%81%E6%97%A0%E6%95%8C%E5%A4%9A%E7%A7%8Djava%E5%9B%9E%E6%BA%AF-%E5%89%AA%E6%9E%9D%E5%81%9A%E6%B3%95%EF%BC%89/"/>
      <url>/2020/04/29/%E5%89%91%E6%8C%87offer-item27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%88%E7%A9%B6%E6%9E%81%E6%97%A0%E6%95%8C%E5%A4%9A%E7%A7%8Djava%E5%9B%9E%E6%BA%AF-%E5%89%AA%E6%9E%9D%E5%81%9A%E6%B3%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这道题思路明显，全排列问题的解决核心就是利用回溯法。只不过这道题全排列的结果可能会包含重复的值，所以还需要应用剪枝来去重，所以下面的几种解法都是利用回溯法思想，只不过剪枝的操作略有不同。</p><p>具体的多种解法见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> flag[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[str.length()];</span><br><span class="line">        String[] strings = str.split(<span class="string">""</span>);</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">        quanpailie(strings,flag,<span class="number">0</span>,strings.length,list,stack);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            String temp = list.get(i).toString();</span><br><span class="line">            String[] temp1 = temp.substring(<span class="number">1</span>,temp.length()-<span class="number">1</span>).split(<span class="string">", "</span>);</span><br><span class="line">            System.out.println(temp1.length);</span><br><span class="line">            StringBuffer SB = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">for</span>(String ss:temp1)&#123;</span><br><span class="line">                SB.append(ss);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!list1.contains(SB.toString()))&#123;</span><br><span class="line">                <span class="comment">//System.out.println(SB.toString().length());</span></span><br><span class="line">                list1.add(SB.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quanpailie</span><span class="params">(String[] str, <span class="keyword">boolean</span>[] flag, <span class="keyword">int</span> cursize, <span class="keyword">int</span> len, List&lt;List&lt;String&gt;&gt; list, Stack&lt;String&gt; stack)</span></span>&#123;<span class="comment">//这里的回溯算法入口的参数过多了，可以设置为私有变量private，从而不需要传入这么多的入参。</span></span><br><span class="line">        <span class="keyword">if</span>(cursize==len)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">                    stack.push(str[i]);</span><br><span class="line">                    flag[i]=<span class="keyword">true</span>;</span><br><span class="line">                    quanpailie(str,flag,cursize+<span class="number">1</span>,len,list,stack);</span><br><span class="line">                    flag[i]=<span class="keyword">false</span>;<span class="comment">//状态重置</span></span><br><span class="line">                    stack.pop();<span class="comment">//状态重置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以明显看出，上面这个代码非常的臃肿繁杂，简化一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span>  ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">if</span>(str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//boolean flag[]=new boolean[str.length()];</span></span><br><span class="line">    String[] strings = str.split(<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//Stack&lt;String&gt; stack = new Stack&lt;String&gt;();</span></span><br><span class="line">    quanpailie(strings,<span class="number">0</span>,strings.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        String temp = list.get(i).toString();</span><br><span class="line">        String[] temp1 = temp.substring(<span class="number">1</span>,temp.length()-<span class="number">1</span>).split(<span class="string">", "</span>);</span><br><span class="line">        System.out.println(temp1.length);</span><br><span class="line">        StringBuffer SB = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(String ss:temp1)&#123;</span><br><span class="line">            SB.append(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!list1.contains(SB.toString()))&#123;</span><br><span class="line">            <span class="comment">//System.out.println(SB.toString().length());</span></span><br><span class="line">            list1.add(SB.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quanpailie</span><span class="params">(String[] str, <span class="keyword">int</span> cursize, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cursize==len)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(stack));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">                stack.push(str[i]);</span><br><span class="line">                flag[i]=<span class="keyword">true</span>;</span><br><span class="line">                quanpailie(str,cursize+<span class="number">1</span>,len);</span><br><span class="line">                flag[i]=<span class="keyword">false</span>;<span class="comment">//状态重置</span></span><br><span class="line">                stack.pop();<span class="comment">//状态重置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] strings = str.split(<span class="string">""</span>);</span><br><span class="line">    quanpailie(strings,<span class="number">0</span>,strings.length);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最核心的就是回溯函数（本质就是递归）以及状态的重置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quanpailie</span><span class="params">(String[] str, <span class="keyword">int</span> cursize, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cursize==len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list.contains(sb.toString()))&#123;<span class="comment">//去重（剪枝），时间复杂度过高，在leetcode会超时</span></span><br><span class="line">            list.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">                sb.append(str[i]);</span><br><span class="line">                flag[i]=<span class="keyword">true</span>;</span><br><span class="line">                quanpailie(str,cursize+<span class="number">1</span>,len);</span><br><span class="line">                flag[i]=<span class="keyword">false</span>;<span class="comment">//状态重置</span></span><br><span class="line">                sb.deleteCharAt(sb.length()-<span class="number">1</span>);<span class="comment">//状态重置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上面剪枝的时间复杂度过高的问题，继续优化如下，利用TreeSet完成去重操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeSet&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();<span class="comment">//利用TreeSet执行去重效果，因为其本身就不支持重复的元素</span></span><br><span class="line">    <span class="keyword">private</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        String[] strings = s.split(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> strings;</span><br><span class="line">        &#125;</span><br><span class="line">        quanpailie(strings,<span class="number">0</span>,strings.length);</span><br><span class="line">        String [] res = <span class="keyword">new</span> String[set.size()];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s1:set)&#123;</span><br><span class="line">            res[i]=s1;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quanpailie</span><span class="params">(String[] strings, <span class="keyword">int</span> current, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current==len)&#123;</span><br><span class="line">            set.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">                    sb.append(strings[i]);</span><br><span class="line">                    flag[i]=<span class="keyword">true</span>;</span><br><span class="line">                    quanpailie(strings,current+<span class="number">1</span>,len);</span><br><span class="line">                    flag[i]=<span class="keyword">false</span>;</span><br><span class="line">                    sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以继续优化，在回溯的期间完成剪枝操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面两种去重操作的时间复杂度都有一些大，这里先将数组排序，然后在添加的时候判断，时间复杂度低一些</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        String[] strings = s.split(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">char</span> [] c = s.toCharArray();</span><br><span class="line">        Arrays.sort(c);<span class="comment">//这里的排序操作是为了后面的去重</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> strings;</span><br><span class="line">        &#125;</span><br><span class="line">        quanpailie(c,<span class="number">0</span>,c.length);</span><br><span class="line">        String [] res = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s1:list)&#123;</span><br><span class="line">            res[i]=s1;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quanpailie</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> current, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current==len)&#123;</span><br><span class="line">            list.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; c[i]==c[i-<span class="number">1</span>] &amp;&amp; !flag[i-<span class="number">1</span>])&#123;<span class="comment">//去重操作（剪枝操作）</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sb.append(c[i]);</span><br><span class="line">                    flag[i]=<span class="keyword">true</span>;</span><br><span class="line">                    quanpailie(c,current+<span class="number">1</span>,len);</span><br><span class="line">                    flag[i]=<span class="keyword">false</span>;</span><br><span class="line">                    sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item26 二叉搜索树与双向链表</title>
      <link href="/2020/04/29/%E5%89%91%E6%8C%87offer-item26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/04/29/%E5%89%91%E6%8C%87offer-item26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>大致思路，二叉搜索树的中序遍历应该就是有序的，我认为这道题的核心就是二叉树的中序遍历方法。返回到是双向链表，却要求不能有新的节点，那么说明肯定不能创建一个链表了，只能修改指针！先把树的node通过中序遍历形成有序的list，再修改list内部Treenode的指针，前一个list节点的右子树指向下一个节点，后一个list节点的左子树则指向前一个节点。</p><p>具体解法见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">item24</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> converindex(LROOTR(pRootOfTree,list));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先中序遍历此二叉树，利用递归即可</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ArrayList&lt;TreeNode&gt; <span class="title">LROOTR</span><span class="params">(TreeNode root, ArrayList&lt;TreeNode&gt;list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            LROOTR(root.left,list);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(root);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            LROOTR(root.right,list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始改变原二叉排序树的指针顺序，改为双向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">converindex</span><span class="params">(ArrayList&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            list.get(i).right = list.get(i+<span class="number">1</span>);</span><br><span class="line">            list.get(i+<span class="number">1</span>).left = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item25 复制复杂链表</title>
      <link href="/2020/04/29/%E5%89%91%E6%8C%87offer-item25-%E5%A4%8D%E5%88%B6%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/04/29/%E5%89%91%E6%8C%87offer-item25-%E5%A4%8D%E5%88%B6%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点：注意此处这个任意一个节点也是属于这个链表中的，这句话很重要！），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这道题关键就是有两点：<br>1.绝对不能直接将引用指向原头节点：<br> RandomListNode node = pHead;<br> return node;<br>上面这样操作，会直接导致输出为空；<br>2.另外一个指针是指向任意节点，注意任意二字！！！甚至可能是指向自己！！！！</p><p>所以，这道题的思想核心就是利用HashMap完成新旧节点的映射关系，新建两个引用，一个负责插入key、value的映射对；而另外一个引用则是用来添加next、和random。具体见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HashMap&lt;RandomListNode,RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        RandomListNode p1 = pHead;</span><br><span class="line">        RandomListNode p2 = pHead;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(p1,<span class="keyword">new</span> RandomListNode(p1.label));</span><br><span class="line">            p1=p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p2.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                map.get(p2).next = map.get(p2.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                map.get(p2).next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(p2).random = map.get(p2.random);</span><br><span class="line">            p2=p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item24 找出二叉树中路径之和为目标值的所有路径</title>
      <link href="/2020/04/29/%E5%89%91%E6%8C%87offer-item24-%E6%89%BE%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
      <url>/2020/04/29/%E5%89%91%E6%8C%87offer-item24-%E6%89%BE%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。<br>    路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br>    (注意: 在返回值的list中，数组长度大的数组靠前)</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>思路有二：<br>    1.将所有的root到叶子节点的路径找出来，建成list，并用val的累加值做key，用后者list当val，再去对比与目标值到hashmap中去找相匹配的key。<br>    2.找路径的时候就加上判断，小于target才继续向下，反之直接停止。我认为本题目的根本还是二叉树的遍历(前序遍历)加一个与target的判断。因为前序遍历本身还是属于DFS的一种，是深度优先，所以适合这种找路径的题目（自上而下）。综上，这道题目的最优解应该为：DFS递归+target目标值计算。具体代码见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">item23</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();<span class="comment">//放置所有路径</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();<span class="comment">//放置某一条路径</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target=target-root.val;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span> &amp;&amp; root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            lists.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">            <span class="comment">//因为result.add(list)是把list这个对象的引用地址添加到result了，result中的元素就会共用list，</span></span><br><span class="line">            <span class="comment">// 而list是我们用来存放当前路径的地方，是一个容器，因此我们需要复制一份之后加入result数组中</span></span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root.left,target);</span><br><span class="line">        FindPath(root.right,target);</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);<span class="comment">//就是一个容器，或者工具，盛满了当然要去除</span></span><br><span class="line">        <span class="comment">//因为当本次递归结束返回上一层的时候，我们已经遍历完这个节点的左右子树，也就是已经该树中可能存在的路径，</span></span><br><span class="line">        <span class="comment">// 再次返回上一层的时候要把这个节点除去，这样在遍历上一个节点的其他子树的时候遍历的结果才是对的</span></span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，这道题的递归思路与回溯法相似，list会涉及到状态重置或者说是状态回溯，因为一条路径找完后需要回到上一个节点继续寻找，存在一个典型的回溯过程。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item23 判断一个数组是否为二叉查找树的后序遍历</title>
      <link href="/2020/04/29/%E5%89%91%E6%8C%87offer-item23-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2020/04/29/%E5%89%91%E6%8C%87offer-item23-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>二叉搜索树的前序遍历一定是有序的，后序遍历的话，根节点在数组最后，前面的数组分为了比root大和比root小的部分，即root的左右子树。如果就这样递归下去，可以将数组中的每一个数统统遍历完成，那么说明结果为二叉搜索树的后序遍历，反之就不是，具体代码见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sequence==<span class="keyword">null</span> || sequence.length==<span class="number">0</span>)&#123;<span class="comment">//增强程序鲁棒性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(sequence,<span class="number">0</span>,sequence.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] sq, <span class="keyword">int</span> start, <span class="keyword">int</span> stop)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;=stop)&#123;<span class="comment">//遍历完成返回结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = sq[stop];<span class="comment">//找到根节点</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sq[start+i]&lt;root)&#123;<span class="comment">//左子树范围</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sq[start+i+j]&gt;root)&#123;<span class="comment">//右子树范围</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i+j!=stop-start)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(sq,start,start+i-<span class="number">1</span>) &amp;&amp; check(sq,spit+i,stop-<span class="number">1</span>);<span class="comment">//分别再进入左右子树开始判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item22 层次遍历二叉树</title>
      <link href="/2020/04/29/%E5%89%91%E6%8C%87offer-item22-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/04/29/%E5%89%91%E6%8C%87offer-item22-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>一层一层的向下遍历二叉树，同一层的话再按照从左向右的顺序进行遍历即可。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>别扯那么多，这就是二叉树的广度优先遍历：BFS。而广度优先遍历的精髓，或者说实现的原理就是队列，保证数据先进先出：先进左边节点、再进右边节点。从而输出就是先左边节点、再右边节点。<br>（补一句：DFS的核心思想，或者底层原理则是栈，先进后出：先进右节点，再进左节点即可）</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; quot = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        quot.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!quot.isEmpty())&#123;</span><br><span class="line">            TreeNode t = quot.remove();</span><br><span class="line">            list.add(t.val);</span><br><span class="line">            <span class="keyword">if</span>(t.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                quot.add(t.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                quot.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><p>层次遍历二叉树，一行输出一层<br>思路还是BFS，只不过在一个地方有微小的不同，那就是需要将当前队列中的所有放置于一个list中，见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=queue.size();i&gt;<span class="number">0</span>;i—)&#123; <span class="comment">//唯一的不同点</span></span><br><span class="line">                TreeNode t = queue.remove();</span><br><span class="line">                list1.add(t.val);</span><br><span class="line">                <span class="keyword">if</span>(t.left!=<span class="keyword">null</span>)queue.add(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right!=<span class="keyword">null</span>)queue.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list1));</span><br><span class="line">            list1.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续拓展，之字形打印二叉树，每一行在一个list内：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</span></span><br><span class="line"><span class="comment">思路有很多：直接设置flag、奇数行偶数行判断添加即可。偶数行加原list1，奇数行将list1反转后再添加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder2(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;<span class="comment">//偶数行</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=queue.size();i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            TreeNode t = queue.remove();</span><br><span class="line">            list1.add(t.val);</span><br><span class="line">            <span class="keyword">if</span>(t.left!=<span class="keyword">null</span>)queue.add(t.left);</span><br><span class="line">            <span class="keyword">if</span>(t.right!=<span class="keyword">null</span>)queue.add(t.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list1));</span><br><span class="line">            list1.clear();</span><br><span class="line">            flag=!flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Collections.reverse(list1);</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list1));</span><br><span class="line">            list1.clear();</span><br><span class="line">            flag=!flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一道基础题，或者是简单题，一定要做到举一反三，才能有所收获！与君共勉~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item21 压栈、出栈顺序判断</title>
      <link href="/2020/04/27/%E5%89%91%E6%8C%87offer-item21-%E5%8E%8B%E6%A0%88%E3%80%81%E5%87%BA%E6%A0%88%E9%A1%BA%E5%BA%8F%E5%88%A4%E6%96%AD/"/>
      <url>/2020/04/27/%E5%89%91%E6%8C%87offer-item21-%E5%8E%8B%E6%A0%88%E3%80%81%E5%87%BA%E6%A0%88%E9%A1%BA%E5%BA%8F%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的<strong>所有数字均不相等</strong>。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题干中所言的所有的数字都不相等，其实是说明了根据入栈的顺序，出栈顺序是唯一的，判断结果不会受到内部重复数字的影响。核心思路是利用一个工具栈来实现，具体思路如下：<br>1.创建一个工具栈，按照入栈数组的顺序压栈；<br>2.判断工具栈的栈顶元素和出栈数组是否一致，一致的话，工具栈弹出栈顶元素，出栈数组也向后移动一位；<br>3.最终判断工具栈是否为空，为空则压栈和出栈顺序匹配返回true，反之不匹配返回flase。</p><p>以上思路的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mport java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">item20</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过一个栈来实现验证：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.首先按照push数组的顺序入栈；</span></span><br><span class="line"><span class="comment">    2.然后将栈顶元素与出栈数组比较是否一样，一样就出栈，然后出栈数组后移。（这里要循环判断）</span></span><br><span class="line"><span class="comment">    3.遍历完出栈序列后，如果辅助栈为空，那么pop序列就是出栈序列，反之就不是。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;pushA.length;i++)&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span>(stack.peek()==popA[j] &amp;&amp; j!=popA.length)&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++; <span class="comment">//这里千万注意了，j=j++这种写法是严重错误的，因为java的中间变量缓存机制！会导致j的值实际没增加。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item20 带min函数的stack栈</title>
      <link href="/2020/04/27/%E5%89%91%E6%8C%87offer-item20-%E5%B8%A6min%E5%87%BD%E6%95%B0%E7%9A%84stack%E6%A0%88/"/>
      <url>/2020/04/27/%E5%89%91%E6%8C%87offer-item20-%E5%B8%A6min%E5%87%BD%E6%95%B0%E7%9A%84stack%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>思路，一开始想着是压根不用栈，直接利用集合模拟栈这种数据结构的pop、push、top，最后再利用Collections工具类进行sort排序，输出第一个值即可。不过这样存在一个问题，时间复杂度太高了，Collection.sort的时间复杂度在O(n2)以上。那么改变思路，用两个栈来实现该算法功能：<br>1.两个栈一个正常存放数据，另一个存放最小值；<br>2.存放最小值的栈内数据的数量和另一个栈要保持一致；<br>3.存放最小值的栈的数据更新策略为：<br>    <strong><em>（1）为空时直接和另一个栈添加一样的数据；<br>    （2）不为空时，如果node比栈顶元素小，那么添加node，反之添加原栈顶元素。</em></strong></p><p>具体解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stackmin = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span>(stackmin.empty())&#123;</span><br><span class="line">            stackmin.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(stackmin.peek()&gt;node)&#123;</span><br><span class="line">                stackmin.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stackmin.push(stackmin.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        stackmin.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackmin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item19 顺时针输出数组</title>
      <link href="/2020/04/27/%E5%89%91%E6%8C%87offer-item19-%E9%A1%BA%E6%97%B6%E9%92%88%E8%BE%93%E5%87%BA%E6%95%B0%E7%BB%84/"/>
      <url>/2020/04/27/%E5%89%91%E6%8C%87offer-item19-%E9%A1%BA%E6%97%B6%E9%92%88%E8%BE%93%E5%87%BA%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>顺时针打印一个二维数组</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>总的来说，这种题目思路很多。譬如就直接按照顺时针的规则进行输出即可，按照上、右、下、左的顺序。只不过每次输出一个方向之后，需要及时修改边界值，也就是去掉已经输出的那一部分。还有一种就是滚动数组，永远输出数组的第一行，不过要让数组不停的顺时针滚动。两种时间复杂度都不低，这里只给出第一种解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/大致思路就是维护四个边界变量，分别对应着矩阵的上、右、下、左边。然后再将边界按照规则递减逐渐缩小即可。</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> width = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> depth = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> size = width*depth;</span><br><span class="line">        <span class="keyword">int</span> mini = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minj=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        loop:<span class="keyword">while</span> (list.size()&lt;size)&#123;</span><br><span class="line">            <span class="comment">//上边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=minj;j&lt;width;j++)&#123;</span><br><span class="line">                list.add(matrix[mini][j]);</span><br><span class="line">                <span class="keyword">if</span>(list.size()==size)&#123;</span><br><span class="line">                    <span class="keyword">break</span> loop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mini++;</span><br><span class="line">            <span class="comment">//右边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=mini;i&lt;depth;i++)&#123;</span><br><span class="line">                list.add(matrix[i][width-<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(list.size()==size)&#123;</span><br><span class="line">                    <span class="keyword">break</span> loop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            width—;</span><br><span class="line">            <span class="comment">//底边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=width-<span class="number">1</span>;j&gt;=minj;j--)&#123;</span><br><span class="line">                list.add(matrix[depth-<span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span>(list.size()==size)&#123;</span><br><span class="line">                    <span class="keyword">break</span> loop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth—;</span><br><span class="line">            <span class="comment">//左边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=depth-<span class="number">1</span>;i&gt;=mini;i--)&#123;</span><br><span class="line">                list.add(matrix[i][minj]);</span><br><span class="line">                <span class="keyword">if</span>(list.size()==size)&#123;</span><br><span class="line">                    <span class="keyword">break</span> loop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minj++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item18 二叉树的镜像</title>
      <link href="/2020/04/26/%E5%89%91%E6%8C%87offer-item18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
      <url>/2020/04/26/%E5%89%91%E6%8C%87offer-item18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>输入一个二叉树，输出其二叉树的镜像。<br>注：镜像为二叉树的所有左右节点交换。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的镜像这种题目在面试中经常会被考到，划重点啦！！！这种题目经典的思路有两种。其一是传统递归；第二种就是非递归解法。</p><h3 id="方法一-传统递归"><a href="#方法一-传统递归" class="headerlink" title="方法一 传统递归"></a>方法一 传统递归</h3><p>递归法没有什么太好说的，既然是左右两个节点交换，那么就是所见即所得，利用递归实现交换就完事儿了。代码见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right=temp;</span><br><span class="line">    Mirror(root.right);</span><br><span class="line">    Mirror(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-利用BFS非递归实现"><a href="#方法二-利用BFS非递归实现" class="headerlink" title="方法二 利用BFS非递归实现"></a>方法二 利用BFS非递归实现</h3><p>在二叉树遍历中，BFS广度优先遍历是一种非常实用的遍历方式。它将二叉树分为一层又一层，那么涉及到二叉树分层操作的题目几乎都可以用BFS来解决一二。每层遍历，然后将每个节点的左右节点交换，从而实现二叉树的镜像。具体代码见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        TreeNode curr,temp;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            curr = queue.remove();</span><br><span class="line">            temp = curr.left;</span><br><span class="line">            curr.left = curr.right;</span><br><span class="line">            curr.right = temp;</span><br><span class="line">            <span class="keyword">if</span>(curr.left!=<span class="keyword">null</span>)queue.add(curr.left);</span><br><span class="line">            <span class="keyword">if</span>(curr.right!=<span class="keyword">null</span>)queue.add(curr.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归这种方法和栈、队列这两种数据结构，在二叉树的遍历以及很多操作中应用广泛。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item17 判断一棵树是不是另外一棵树的子结构</title>
      <link href="/2020/04/26/%E5%89%91%E6%8C%87offer-item17-%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%A6%E5%A4%96%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
      <url>/2020/04/26/%E5%89%91%E6%8C%87offer-item17-%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%A6%E5%A4%96%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p><em>题干：</em><br>判断一棵树是不是另一棵树的子结构</p><p><strong><em>思路：</em></strong></p><p>这道题值得注意的就是区分清楚什么是子树，什么是子结构。</p><h2 id="子树："><a href="#子树：" class="headerlink" title="子树："></a>子树：</h2><p>是只要包含了一个结点，就得包含这个结点下的所有节点。</p><h2 id="子结构："><a href="#子结构：" class="headerlink" title="子结构："></a>子结构：</h2><p>包含了一个结点，可以只取左子树或者右子树，或者都不取。也就是说，单单一个节点都可以是一个子结构。</p><h2 id="具体代码如下："><a href="#具体代码如下：" class="headerlink" title="具体代码如下："></a>具体代码如下：</h2><p><strong><em>判断一棵树是不是另外一棵树的子结构：</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span> || root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> judge(root1,root2) || judge(root1.left,root2) || judge(root1.right,root2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">       <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1.val!=root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> judge(root1.left,root2) || judge(root1.right,root2);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> judge(root1.left, root2.left) &amp;&amp; judge(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong><em>判断一棵树是不是另外一棵树的子树：</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span> || root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//空树没有任何一个子树，空树也不是任何一个树的子树</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> judge(root1,root2) || judge(root1.left,root2) || judge(root1.right,root2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//root2所有节点已经判断完毕，是子树</span></span><br><span class="line">        &#125; </span><br><span class="line">       <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//root1的所有节点已经判断完毕，不是子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1.val!=root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//因为子树是要从这个节点到叶子节点的所有节点都相同才可以</span></span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> judge(root1.left, root2.left) &amp;&amp; judge(root1.right, root2.right);<span class="comment">//完成了上面的判断，继续进行树的下一层判断。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这些细节一定要分清楚了！！！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>无关痛痒的一些闲话</title>
      <link href="/2020/04/25/%E6%97%A0%E5%85%B3%E7%97%9B%E7%97%92%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%B2%E8%AF%9D/"/>
      <url>/2020/04/25/%E6%97%A0%E5%85%B3%E7%97%9B%E7%97%92%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%B2%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<p>这是一个被疫情打乱的2020</p><p>以前全部的理所应当在现在都有些勉强</p><p>最近发现可能生活真的需要一点的不一样</p><p>每天三点一线  为了money</p><p>真的快乐么</p><p>还是说人生而就是为了赎罪</p><p>我是一个很乐观的人</p><p>但是乐观不代表没有悲观</p><p>我会沮丧</p><p>我会失望</p><p>我在期待</p><p>我也会害怕</p><p>但是似乎每一个明天的我都会逐渐的释怀</p><p>逐渐的忘记</p><p>希望</p><p>我能一直这样</p><p>平安喜乐</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item16 合并排序链表</title>
      <link href="/2020/04/23/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item16-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/04/23/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item16-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><h1 id="题干："><a href="#题干：" class="headerlink" title="题干："></a><strong><em>题干：</em></strong></h1><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong><em>思路：</em></strong></h1><p>这道题的方法有很多，首先大类分为两种：<strong><em>1.使用额外的空间；2.使用递归在原先链表中进行操作。</em></strong></p><h2 id="1-使用额外的空间"><a href="#1-使用额外的空间" class="headerlink" title="1.使用额外的空间"></a>1.使用额外的空间</h2><p>在这种思路中，可以两种额外空间的方式。第一种采用集合将两个链表中的val全部取出，然后隔离链表进行排序，之后再赋值给原先链表或者再新建一个链表。这种方法思路出气简单，新手一般会采用。但是空间和时间复杂度都很大。具体代码加下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ListNode temp1 = list1;</span><br><span class="line">    ListNode temp2 = list2;</span><br><span class="line">    ListNode temp3 = list1;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (list1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(list1.val);</span><br><span class="line">        list1=list1.next;</span><br><span class="line">        flag++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (list2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(list2.val);</span><br><span class="line">        list2=list2.next;</span><br><span class="line">        flag1++;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;flag;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp1.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        temp1.val=list.get(i);</span><br><span class="line">        temp1=temp1.next;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp1.val=list.get(i);</span><br><span class="line">            temp1.next=temp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=flag;i&lt;flag1+flag;i++)&#123;</span><br><span class="line">        temp2.val=list.get(i);</span><br><span class="line">        temp2=temp2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么第二种就是新建一个ListNode，然后去比较list1和list2，哪一个小一些就先加在这个新建的ListNode后面。代码见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode c = newNode;</span><br><span class="line">        <span class="keyword">while</span> (list1!=<span class="keyword">null</span> &amp;&amp; list2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">                newNode.next = list1;</span><br><span class="line">                list1=list1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                newNode.next = list2;</span><br><span class="line">                list2=list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            newNode=newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            newNode.next = list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            newNode.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-使用递归在原先链表中进行操作。"><a href="#2-使用递归在原先链表中进行操作。" class="headerlink" title="2.使用递归在原先链表中进行操作。"></a>2.使用递归在原先链表中进行操作。</h2><p>递归操作简单明了，直接给出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">                list1.next = Merge(list1.next,list2);</span><br><span class="line">                <span class="keyword">return</span> list1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                list2.next = Merge(list1,list2.next);</span><br><span class="line">                <span class="keyword">return</span> list2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总而言之，三种方法都可解决此问题！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item15 翻转链表</title>
      <link href="/2020/04/23/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item15-%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/04/23/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item15-%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p><strong><em>题干：</em></strong><br>将一个链表进行翻转。</p><p><strong><em>思路：</em></strong><br>这道题的思路明显，有两种典型思路解决。<br><strong>思路一</strong>：”假“翻转。所谓假翻转的意思就是，仅仅只翻转链表节点内部的数值，不翻转节点本身。具体而言，将链表内部的数值用集合”盛“出来，然后对这个链表进行翻转操作，最后再利用这个集合为链表重新赋值。值得一提的是，这种方法，链表节点之间的相互引用关系并未发生改变，变化的仅仅是节点内部的值。</p><p><strong>思路二</strong>：”真“翻转。所谓真翻转是针对”假“翻转而言的，这中方法会利用中间节点真正的实现相邻节点的顺序翻转。效率更高，也是这道题目我推荐的解法。</p><p>下面分别给出两种解法的具体代码：</p><p>way1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只换值，不换前后映射关系，即不换前后节点的引用指向。</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ListNode head1= head;</span><br><span class="line">    ListNode cc=head;</span><br><span class="line">    <span class="keyword">while</span> (head1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(head1.val);</span><br><span class="line">        head1=head1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(list);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        head.val=list.get(i);</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>way2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;<span class="comment">//这里是把引用指向修改，本身val数值不变，并非把整个节点修改，但是仍然实现了反转的效果</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>可以将pre与curr看成是一组翻转工具，不停的执行相邻两个链表节点的翻转操作。</em></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item14 链表中的倒数第k个节点</title>
      <link href="/2020/04/23/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/2020/04/23/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p><strong><em>题干：</em></strong><br>输入一个链表，输出该链表中倒数第k个结点</p><p><strong><em>思路：</em></strong><br>分析，链表没有直接出长度的函数，所以涉及到输出链表中的倒数第几个结点，首先要把链表中的节点数搞清楚，然后再输出即可，主要判断几个条件：链表是否为空了，k是否大于链表中的结点数了。这是最常规的做法，时间复杂度会达到O（2n），这里暂且叫做method1。代码见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || (head.next==<span class="keyword">null</span> &amp;&amp; k!=<span class="number">1</span>))&#123;<span class="comment">//程序鲁棒性检测</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="keyword">null</span> &amp;&amp; k==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;<span class="comment">//i代表这个链表的节点数</span></span><br><span class="line">    ListNode index = head;</span><br><span class="line">    <span class="keyword">while</span> (index.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        index=index.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;i)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i-k;j++)&#123;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这种方法实际做了很多无用功，要先去统计链表中的节点数目。</p><h2 id="这种题目的最经典解法是利用双指针求解。"><a href="#这种题目的最经典解法是利用双指针求解。" class="headerlink" title="这种题目的最经典解法是利用双指针求解。"></a><em>这种题目的最经典解法是利用双指针求解。</em></h2><p><strong>原理如下：</strong><br>设置两个指针分别指向头结点，一个是快指针fhead，一个慢指针lhead。fhead先出发，走出k-1步之后，lhead开始出发。二者始终差k-1个距离，当fhead到达链表末尾的时候，lhead所在位置就是链表中倒数第k个数。<br>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;<span class="comment">//增强程序的鲁棒性（强壮性）：输入链表为null时，保证正确输出。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast= head;</span><br><span class="line">        ListNode low = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">                low=low.next;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k!=<span class="number">1</span>)&#123;<span class="comment">//增强程序的鲁棒性（强壮性）：保证在k值比链表长度还长的是时候正确输出。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>双指针法的思路非常优秀，且简单明了，非常推荐使用！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item13 数组操作</title>
      <link href="/2020/04/23/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item13-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/04/23/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item13-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p><strong><em>题干：</em></strong><br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p><strong><em>思路：</em></strong><br>这道题的题干中对于时间复杂度的要求要高于对空间复杂度的要求，所以完全可以将集合利用起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list1= <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list2= <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                list2.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                list1.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list1.addAll(list2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            array[i]=list1.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种非常非常简单且常规的数组操作题目，利用额外的空间来实现算法需求，很多情况下是不允许利用额外空间的，这就值得我们思考了🤔，持续更新。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item12 求double数的int次方</title>
      <link href="/2020/04/22/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item12-%E6%B1%82double%E6%95%B0%E7%9A%84int%E6%AC%A1%E6%96%B9/"/>
      <url>/2020/04/22/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item12-%E6%B1%82double%E6%95%B0%E7%9A%84int%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p><strong><em>题干：</em></strong><br>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 </p><p>保证base和exponent不同时为0</p><p><strong><em>思路：</em></strong><br>本题只要不要忘记这个次数可正可负，就是一道无敌简单的题目。下面首先给出常规做法，即分exponent的正负情况进行累乘即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;exponent;i++)&#123;</span><br><span class="line">                sum=sum*base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;-exponent;i++)&#123;</span><br><span class="line">                sum=sum*base;</span><br><span class="line">            &#125;</span><br><span class="line">            sum=<span class="number">1</span>/sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>然而这只是一种非常常规的做法，在exponent很大的时候，显然不够高效。我们试着分析一下，在计算n次方时，其实有很多可以讨巧的地方。譬如8次方可以用4次方的平方来表示，而4次方又可以用平方的平方来表示。而累乘中却忽视了这一点，只是无脑的从小累乘到大，在数据比较大的时候显然是不够高效的。进一步给出分析如下：</strong></p><p>从而得到最终的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Power1</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//设置标志位，根据标志位输出倒数或者原数</span></span><br><span class="line">    <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;<span class="comment">//负数无法用右移1位实现除以2，所以所有的负数全部转为正数</span></span><br><span class="line">        flag=<span class="keyword">false</span>;</span><br><span class="line">        exponent=-exponent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> res = unitpower(base,exponent);</span><br><span class="line">    <span class="keyword">return</span> flag ? res : <span class="number">1</span>/res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">unitpower</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exponent==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(exponent==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> res = unitpower(base,exponent &gt;&gt; <span class="number">1</span>);<span class="comment">//每次递归将exponent除以2</span></span><br><span class="line">    res *=res; <span class="comment">//exponent为偶数</span></span><br><span class="line">    <span class="keyword">if</span>((exponent &amp; <span class="number">1</span>)==<span class="number">1</span>)&#123;<span class="comment">//exponent为奇数，同样我们可以用正数&amp;1的值来判断奇数偶数</span></span><br><span class="line">        res *=base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>值得一提的是，为了进一步去简化整个代码，用位计算代替了除以2和取余判断奇偶，因为位运算比加减乘数取余的效率高的多。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item11 一个整数的二进制有多少个1</title>
      <link href="/2020/04/22/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item11-%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA1/"/>
      <url>/2020/04/22/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item11-%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA1/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p><strong><em>题干：</em></strong></p><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p><strong><em>思路：</em></strong></p><p>首先要明确一点，在计算机中数字都是以二进制来进行的，机器不认识整数，输入一个整数后，会自动转为二进制数在计算机中进行操作。且看到这个题目的后半句，负数用补码来表示，值得一提的是，<strong>在整个计算机中，数字的运算都是以补码来进行的</strong>。而正数的补码就是其本身，所以这道题这句话在这里相当于画蛇添足。下面给出具体的思路分析（一次性永远记忆即可）：<strong>一个二进制数，减去1，再和其本身相与，就会将这个二进制数最右边的那个1变成0，重复这个过程就会把二进制数所有的1都变0，那么这个数也就变成了0，从而也就统计出了其中1的个数</strong>。具体代码见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        n=n&amp;(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法除了需要有时的灵光乍现之外，更多的是需要自身的积累。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item10 拼接矩形</title>
      <link href="/2020/04/22/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item10-%E6%8B%BC%E6%8E%A5%E7%9F%A9%E5%BD%A2/"/>
      <url>/2020/04/22/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item10-%E6%8B%BC%E6%8E%A5%E7%9F%A9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p><strong><em>题干：</em></strong></p><p><img src="https://img-blog.csdnimg.cn/20200422151631118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODEwNzMxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong><em>思路：</em></strong><br>这道题乍一看，没什么思路，感觉又需要分析最终拼接的这个长方形的高还要分析宽。但是实际我们分析，这个长方形的长也好，宽也罢，只能有1或者2组合形成，而且一旦确定了长方形长的组合方法，这个拼接长方形也就确定了，自然不需要再去分析宽。有意思的是，长只能由1、2组合而成，这不就是爬楼梯问题么？所以又转回了我们之前讨论的爬楼梯问题——也就是动态规划问题。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//其实就是斐波那契数列（因为边只能是有1或者2组成，就相当于N个台阶，每次只能上1个或者2个，问上去能有几种方法）</span></span><br><span class="line">         <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，很多问题都是融会贯通的，分析算法题的重点之一一定是把题干掰碎了。与君共勉~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于二叉树还原和遍历的一道综合题目</title>
      <link href="/2020/04/21/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%98%E5%8E%9F%E5%92%8C%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%80%E9%81%93%E7%BB%BC%E5%90%88%E9%A2%98%E7%9B%AE/"/>
      <url>/2020/04/21/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%98%E5%8E%9F%E5%92%8C%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%80%E9%81%93%E7%BB%BC%E5%90%88%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<hr><p>author:Sirius tjq</p><p><strong><em>题干：</em></strong><br>输入树的前序和中序遍历，以空格分开，输出这个树的后序遍历<br><img src="https://img-blog.csdnimg.cn/20200420223128699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODEwNzMxNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong><em>思路：</em></strong><br>这种题属于对树的操作的综合性题目，首先根据树的前序和中序遍历得到这个树，也就是所谓的树还原。然后再进行树的后序遍历即可。</p><p>根据上面的分析，得到下面的算法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定一个树的前序和中序，输出这个树的后序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入前序和后序以空格分开</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">item70</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner ss = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str1 = ss.next();</span><br><span class="line">        String str2 = ss.next();</span><br><span class="line">        String[] pre = str1.split(<span class="string">""</span>);</span><br><span class="line">        String[] inorder = str2.split(<span class="string">""</span>);</span><br><span class="line">        lastorder(rebuilt(pre,inorder));</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还原树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode1 <span class="title">rebuilt</span><span class="params">(String[] pre, String[] inoeder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length==<span class="number">0</span> || inoeder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode1 root = <span class="keyword">new</span> TreeNode1(pre[<span class="number">0</span>]);<span class="comment">//根据前序遍历确定根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inoeder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inoeder[i].equals(pre[<span class="number">0</span>]))&#123;</span><br><span class="line">                root.left = rebuilt(Arrays.copyOfRange(pre,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inoeder,<span class="number">0</span>,i));<span class="comment">//左子树</span></span><br><span class="line">                root.right = rebuilt(Arrays.copyOfRange(pre,i+<span class="number">1</span>,pre.length),Arrays.copyOfRange(inoeder,i+<span class="number">1</span>,inoeder.length));<span class="comment">//右子树</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastorder</span><span class="params">(TreeNode1 node)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           lastorder(node.left);</span><br><span class="line">           lastorder(node.right);</span><br><span class="line">           sb.append(node.val);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer----item9 变态跳台阶</title>
      <link href="/2020/04/21/%E5%89%91%E6%8C%87offer-item9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2020/04/21/%E5%89%91%E6%8C%87offer-item9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p><strong><em>题干</em></strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p><strong><em>思路：</em></strong><br>这只青蛙不是简单的青蛙了，一次能跳到n个台阶，但是思路还是动态规划的思路，只不过是动态规划转移方程变了：<br>f(n)=f(n-1)+f(n-2)+….+1</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[]=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;target+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                dp[i]=dp[i]+dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见平时学习的举一反三是很重要的！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item8 跳台阶</title>
      <link href="/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item8-%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item8-%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p><strong><em>题干：</em></strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><p><strong><em>思路：</em></strong><br>这道题就是斐波那契数列，也就是动态规划。解法和item7一致，可以去查看我的上一篇博客。这里就不再赘述，直接给出代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;target+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item7 斐波那契数列</title>
      <link href="/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p><strong><em>题干：</em></strong><br>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39</p><p><strong><em>思路：</em></strong><br>其实，斐波那契数列算是动态规划算法的究极简单例子之一了。目前的动态规划算法中的起始例子大多都是从斐波那契数列讲起。我这里就多啰嗦几句，说一下斐波那契数列。</p><p>F（n）= F（n-1）+ F（n-2），且F（1）=F（2）=1；</p><p>这就是斐波那契数列的通项式子。只不过这道题n是从0开始的而已。斐波那契数列之所以经常被放在动态规划当中讲是因为斐波那契数列的每一项都可以看做是某一个特定的状态，而这个状态是由过去的状态（n-1、n-2）来决定的。同时值得一提的是，这个状态还会影响未来的状态。也就是将一个大的问题分解成了若干个小问题的和的形式，这种问题一般是由动态规划来解决的。</p><p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p><pre><code>（1）问题的阶段 （2）每个阶段的状态（3）从前一个阶段转化到后一个阶段之间的递推关系。</code></pre><p>递推关系必须是从==次小的问题开始到较大的问题之间的转化==，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p><p>确定了动态规划的这三要素，整个求解过程就可以用一个==最优决策表==来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题在==某个阶段某个状态下的最优值==（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。<br>递推公式或者叫做动态规划状态转移公式：<br>          f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}</p><p>说了这么多，其实就是要告诉大家这道题，有两种解法：<br>1、传统递归<br>2、利用动态规划完成</p><p>具体代码见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fibonacci1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci1(n-<span class="number">1</span>)+Fibonacci1(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];<span class="comment">//主要初始化数组的长度</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//初始化动态规划数组</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//初始化动态规划数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们来看一下采用递归方法和动态规划方法的时间长短：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">采用递归耗时<span class="number">1.0</span>毫秒</span><br><span class="line"><span class="number">5</span></span><br><span class="line">采用动态规划耗时<span class="number">0.0</span>毫秒</span><br></pre></td></tr></table></figure><p>明显采用递归耗时更多，因为递归有很多重复计算，而动态规划直接采用动态规划数组承载了过去的状态，即动态规划是在用空间换时间的一种算法，在内存空间较为宽裕而对运行时间要求比较高的场景中应用广泛。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item6 旋转数组的最小值</title>
      <link href="/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
      <url>/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p><strong><em>题干：</em></strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p><strong><em>思路：</em></strong><br>这种题典型的纸老虎，题干一通瞎吹，高大上的不行，实际就一数组中的最小值求解。我一开始也觉得暗藏玄机，但是仔细一分析，首先旋转数组的旋转规则没有，其次旋转数组的原生数组状态也没有，所以这道题就是在侮辱我的智商，就是简简单单的输出数组中的最小值。</p><p>详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i]&lt;min)&#123;</span><br><span class="line">                    min=array[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，把题干的外套拔下来，很重要！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item5 用两个栈实现队列</title>
      <link href="/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item5-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item5-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p><strong><em>题干：</em></strong><br>如题所示，利用两个栈实现队列。首先明确一点，Java中是没有队列这种数据结构的，只有Queue这个抽象类，我们一般是用Collection集合类下面的LinkedList来模拟队列这种数据结构。</p><p><strong><em>思路：</em></strong><br>好了，扯了那么多，回归正题。栈这种数据结构的特点是先进后出，而队列则是先进先出。那么用栈来模拟实现队列的方法就是一个栈用来加入元素，另外一个栈来pop元素。具体而言：</p><p>stack1：所有的队列push操作，全部加到这个stack内；<br>stack2：当队列要执行pop操作时，先判断stack2是否为空。为空则将stack1内部所有的元素pop出来再依序push进入stack2中，然后再stack2中执行pop操作即可。不为空则直接对stack2执行pop操作。</p><p>具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">item5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么看来，数据结构还是很有研究性的~~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item4 还原树</title>
      <link href="/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item4-%E8%BF%98%E5%8E%9F%E6%A0%91/"/>
      <url>/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item4-%E8%BF%98%E5%8E%9F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p>题目描述</p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p><strong><em>思路：</em></strong><br>其实就是从前序中找出根节点，再对应着去中序中找左子树和右子树，关键是递归的问题，值得记录。<br>例如：<br>前序序列{1,2,4,7,3,5,6,8} = pre<br>中序序列{4,7,2,1,5,3,8,6} = in</p><ol><li>根据当前前序序列的第一个结点确定根结点，为 1 </li><li>找到 1 在中序遍历序列中的位置，为 in[3] </li><li>切割左右子树，则 in[3] 前面的为左子树， in[3] 后面的为右子树 </li><li>则切割后的左子树前序序列为：{2,4,7}，切割后的左子树中序序列为：{4,7,2}；切割后的右子树前序序列为：{3,5,6,8}，切割后的右子树中序序列为：{5,3,8,6} </li><li>对子树分别使用同样的方法分解</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 在中序中找到前序的根</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// 左子树，注意 copyOfRange 函数，左闭右开</span></span><br><span class="line">                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">                <span class="comment">// 右子树，注意 copyOfRange 函数，左闭右开</span></span><br><span class="line">                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + <span class="number">1</span>, pre.length), Arrays.copyOfRange(in, i + <span class="number">1</span>, in.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item3字符串空格替换</title>
      <link href="/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2/"/>
      <url>/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p>题干：<br>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p><strong><em>分析：</em></strong><br>        这题属于简单题，思路有2.其一利用额外的空间，直接再创建一个StringBuffer，将这个Buffer中的内容向其中添加即可，遇到空格添加”%20“，反之添加其原本的内容。其二即为在原buffer上进行修改，直接在原位置上用replace替换为“%20”。<br>        注意这里容易发生错误的是repalce方法，看下面两个例子：</p><p>我们想要将a替换为t</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">     sb.append(<span class="string">"dasd"</span>);</span><br><span class="line">     <span class="comment">//sb.deleteCharAt(1);</span></span><br><span class="line">     sb.replace(<span class="number">1</span>,<span class="number">2</span>,<span class="string">"t"</span>);</span><br><span class="line">     System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><p>输出为dtsd，符合预期</p><p>另外一种写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">      sb.append(<span class="string">"dasd"</span>);</span><br><span class="line">      <span class="comment">//sb.deleteCharAt(1);</span></span><br><span class="line">      sb.replace(<span class="number">1</span>,<span class="number">1</span><span class="string">"t"</span>);</span><br><span class="line">      System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><p>输出为dtasd，并未实现替换，而是在原位置上进行了添加，为什么呢？原因很简单，StringBuffer的replace方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span> </span>&#123;</span><br><span class="line">        toStringCache = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">super</span>.replace(start, end, str);<span class="comment">//继承其父类的replace方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见StringBuffer的replace方法是直接继承了其父类AbstractStringBuffer的replace方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span> </span>&#123;</span><br><span class="line"><span class="comment">//前面几个if都是为了增强方法的鲁棒性</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(start);</span><br><span class="line">        <span class="keyword">if</span> (start &gt; count)<span class="comment">//count为StringBuffer中实际被使用的字符串个数</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(<span class="string">"start &gt; length()"</span>);</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(<span class="string">"start &gt; end"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (end &gt; count)</span><br><span class="line">            end = count;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">int</span> newCount = count + len - (end - start);</span><br><span class="line">        ensureCapacityInternal(newCount);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(value, end, value, start + len, count - end);<span class="comment">//此为核心步骤，利用System.arraycopy方法，将原数组的扩容len长度，扩容起始位置为start，从end及其之后的元素也要相应的向后移动len长度，明显从end开始的内容都未被删除，而是直接后移了len长度，只有start到end-1的位置被替换</span></span><br><span class="line">        str.getChars(value, start);<span class="comment">//将目标字符串添加进刚刚扩容的空闲空间内，实现替换</span></span><br><span class="line">        count = newCount;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体方法1的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法2如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)&#123;</span><br><span class="line">                sb.replace(i,i+<span class="number">1</span>,<span class="string">"%20"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由此可见，这么简单的一道题目，如果深挖源码的话，还是有蛮多值得思考的东西的，与君共勉~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item2 从尾到头打印链表</title>
      <link href="/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item2-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item2-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<hr><p>author: Sirius tjq</p><p>题干：<br>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p><strong><em>分析：</em></strong><br>        链表查找比数组慢的多，这是因为<strong>链表的每个节点是存储在堆空间中，而数组则部分或全部存储在CPU缓存中，系统对CPU缓存的读取速度是内存的33倍</strong>（cpu缓存3个时钟周期，而内存的读取则需要100个时钟周期）。所以本题目绝不是先找到链表尾部然后开始添加到list中，而是从而到位添加到list中之后，再通过集合的操作类Collections进行反转即可。</p><p>具体代码见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">            listNode=listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一点思考🤔，这道题目只是题干的方法返回值限定为了Integer，不然的话其实直接将ListNode加到List中也是完全可以的。</p><p>方法很多，欢迎大家交流~~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列----item1 二维数组的查找</title>
      <link href="/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/04/21/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<hr><p>author:Sirius tjq</p><p>从今天开始，我将会更新剑指offer中的全部算法题目，当时第一遍刷题比较慢，花了一个月的时间，而且分析很多不太到位，今天开始重新总结一遍，并加深思考和拓展，争取做到举一反三。</p><p><strong><em>题干：</em></strong></p><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong><em>思路：</em></strong></p><p>这道题暴力法绝对超时，本质一看到有序，肯定想到了二分查找，二维数组有几行，就对每一行进行<strong>二分查找</strong>即可。我认为本题的关键在于，如何判断二维数组是空的：<br>二维数组为空，要检查三个部分:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一、是数组首地址是否为空，即array==<span class="keyword">null</span>是否成立。</span><br><span class="line">二、是是否为&#123; &#125;，也就是array.length==<span class="number">0</span>的情况。</span><br><span class="line">三、是&#123;&#123; &#125;&#125;，这时array.length=<span class="number">1</span>，但是array[<span class="number">0</span>].length==<span class="number">0</span>。满足任意一个条件就可以返回<span class="keyword">false</span>了。</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line"><span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>||(array.length==<span class="number">1</span>&amp;&amp;array[<span class="number">0</span>].length==<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>在进行了上述分析之后，答案已经呼之欲出了，具体见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>||(array.length==<span class="number">1</span>&amp;&amp;array[<span class="number">0</span>].length==<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n=array.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> []c:array)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[n/<span class="number">2</span>]&gt;target)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c[i]==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c[i]==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
