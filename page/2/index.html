<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="为保证浏览效果，请尽量使用Chrome">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    Hogwarts library</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay=""
             poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">Hogwarts library</a></h1>
      <p>欢迎来到Siriustjq的世界</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="Hogwarts library"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
    <article class="articles">
      
      <h1 class="page-type-title"></h1>
      
        
          <article id="post-剑指offer-item23-判断一个数组是否为二叉查找树的后序遍历" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/04/29/%E5%89%91%E6%8C%87offer-item23-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/">剑指offer系列----item23 判断一个数组是否为二叉查找树的后序遍历</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/29/%E5%89%91%E6%8C%87offer-item23-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" class="article-date">
  <time datetime="2020-04-29T11:23:29.000Z" itemprop="datePublished">2020-04-29</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>二叉搜索树的前序遍历一定是有序的，后序遍历的话，根节点在数组最后，前面的数组分为了比root大和比root小的部分，即root的左右子树。如果就这样递归下去，可以将数组中的每一个数统统遍历完成，那么说明结果为二叉搜索树的后序遍历，反之就不是，具体代码见下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sequence==<span class="keyword">null</span> || sequence.length==<span class="number">0</span>)&#123;<span class="comment">//增强程序鲁棒性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(sequence,<span class="number">0</span>,sequence.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] sq, <span class="keyword">int</span> start, <span class="keyword">int</span> stop)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;=stop)&#123;<span class="comment">//遍历完成返回结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = sq[stop];<span class="comment">//找到根节点</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sq[start+i]&lt;root)&#123;<span class="comment">//左子树范围</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sq[start+i+j]&gt;root)&#123;<span class="comment">//右子树范围</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i+j!=stop-start)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(sq,start,start+i-<span class="number">1</span>) &amp;&amp; check(sq,spit+i,stop-<span class="number">1</span>);<span class="comment">//分别再进入左右子树开始判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/04/29/%E5%89%91%E6%8C%87offer-item23-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" data-id="ck9l93skc0001b5tdcbb23u55" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer-item22-层次遍历二叉树" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/04/29/%E5%89%91%E6%8C%87offer-item22-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/">剑指offer系列----item22 层次遍历二叉树</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/29/%E5%89%91%E6%8C%87offer-item22-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time datetime="2020-04-29T11:22:10.000Z" itemprop="datePublished">2020-04-29</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>一层一层的向下遍历二叉树，同一层的话再按照从左向右的顺序进行遍历即可。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>别扯那么多，这就是二叉树的广度优先遍历：BFS。而广度优先遍历的精髓，或者说实现的原理就是队列，保证数据先进先出：先进左边节点、再进右边节点。从而输出就是先左边节点、再右边节点。<br>（补一句：DFS的核心思想，或者底层原理则是栈，先进后出：先进右节点，再进左节点即可）</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; quot = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        quot.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!quot.isEmpty())&#123;</span><br><span class="line">            TreeNode t = quot.remove();</span><br><span class="line">            list.add(t.val);</span><br><span class="line">            <span class="keyword">if</span>(t.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                quot.add(t.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                quot.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><p>层次遍历二叉树，一行输出一层<br>思路还是BFS，只不过在一个地方有微小的不同，那就是需要将当前队列中的所有放置于一个list中，见下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=queue.size();i&gt;<span class="number">0</span>;i—)&#123; <span class="comment">//唯一的不同点</span></span><br><span class="line">                TreeNode t = queue.remove();</span><br><span class="line">                list1.add(t.val);</span><br><span class="line">                <span class="keyword">if</span>(t.left!=<span class="keyword">null</span>)queue.add(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right!=<span class="keyword">null</span>)queue.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list1));</span><br><span class="line">            list1.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续拓展，之字形打印二叉树，每一行在一个list内：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</span></span><br><span class="line"><span class="comment">思路有很多：直接设置flag、奇数行偶数行判断添加即可。偶数行加原list1，奇数行将list1反转后再添加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder2(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;<span class="comment">//偶数行</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=queue.size();i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            TreeNode t = queue.remove();</span><br><span class="line">            list1.add(t.val);</span><br><span class="line">            <span class="keyword">if</span>(t.left!=<span class="keyword">null</span>)queue.add(t.left);</span><br><span class="line">            <span class="keyword">if</span>(t.right!=<span class="keyword">null</span>)queue.add(t.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list1));</span><br><span class="line">            list1.clear();</span><br><span class="line">            flag=!flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Collections.reverse(list1);</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list1));</span><br><span class="line">            list1.clear();</span><br><span class="line">            flag=!flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一道基础题，或者是简单题，一定要做到举一反三，才能有所收获！与君共勉~</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/04/29/%E5%89%91%E6%8C%87offer-item22-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="ck9l923ee0000b5td8fzhgf0s" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer-item21-压栈、出栈顺序判断" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/04/27/%E5%89%91%E6%8C%87offer-item21-%E5%8E%8B%E6%A0%88%E3%80%81%E5%87%BA%E6%A0%88%E9%A1%BA%E5%BA%8F%E5%88%A4%E6%96%AD/">剑指offer系列----item21 压栈、出栈顺序判断</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/27/%E5%89%91%E6%8C%87offer-item21-%E5%8E%8B%E6%A0%88%E3%80%81%E5%87%BA%E6%A0%88%E9%A1%BA%E5%BA%8F%E5%88%A4%E6%96%AD/" class="article-date">
  <time datetime="2020-04-27T12:18:15.000Z" itemprop="datePublished">2020-04-27</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的<strong>所有数字均不相等</strong>。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题干中所言的所有的数字都不相等，其实是说明了根据入栈的顺序，出栈顺序是唯一的，判断结果不会受到内部重复数字的影响。核心思路是利用一个工具栈来实现，具体思路如下：<br>1.创建一个工具栈，按照入栈数组的顺序压栈；<br>2.判断工具栈的栈顶元素和出栈数组是否一致，一致的话，工具栈弹出栈顶元素，出栈数组也向后移动一位；<br>3.最终判断工具栈是否为空，为空则压栈和出栈顺序匹配返回true，反之不匹配返回flase。</p>
<p>以上思路的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mport java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">item20</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过一个栈来实现验证：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.首先按照push数组的顺序入栈；</span></span><br><span class="line"><span class="comment">    2.然后将栈顶元素与出栈数组比较是否一样，一样就出栈，然后出栈数组后移。（这里要循环判断）</span></span><br><span class="line"><span class="comment">    3.遍历完出栈序列后，如果辅助栈为空，那么pop序列就是出栈序列，反之就不是。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;pushA.length;i++)&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span>(stack.peek()==popA[j] &amp;&amp; j!=popA.length)&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++; <span class="comment">//这里千万注意了，j=j++这种写法是严重错误的，因为java的中间变量缓存机制！会导致j的值实际没增加。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/04/27/%E5%89%91%E6%8C%87offer-item21-%E5%8E%8B%E6%A0%88%E3%80%81%E5%87%BA%E6%A0%88%E9%A1%BA%E5%BA%8F%E5%88%A4%E6%96%AD/" data-id="ck9ig6isz0002zhtddwt26stm" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer-item20-带min函数的stack栈" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/04/27/%E5%89%91%E6%8C%87offer-item20-%E5%B8%A6min%E5%87%BD%E6%95%B0%E7%9A%84stack%E6%A0%88/">剑指offer系列----item20 带min函数的stack栈</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/27/%E5%89%91%E6%8C%87offer-item20-%E5%B8%A6min%E5%87%BD%E6%95%B0%E7%9A%84stack%E6%A0%88/" class="article-date">
  <time datetime="2020-04-27T11:59:56.000Z" itemprop="datePublished">2020-04-27</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>思路，一开始想着是压根不用栈，直接利用集合模拟栈这种数据结构的pop、push、top，最后再利用Collections工具类进行sort排序，输出第一个值即可。不过这样存在一个问题，时间复杂度太高了，Collection.sort的时间复杂度在O(n2)以上。那么改变思路，用两个栈来实现该算法功能：<br>1.两个栈一个正常存放数据，另一个存放最小值；<br>2.存放最小值的栈内数据的数量和另一个栈要保持一致；<br>3.存放最小值的栈的数据更新策略为：<br>    <strong><em>（1）为空时直接和另一个栈添加一样的数据；<br>    （2）不为空时，如果node比栈顶元素小，那么添加node，反之添加原栈顶元素。</em></strong></p>
<p>具体解法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stackmin = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span>(stackmin.empty())&#123;</span><br><span class="line">            stackmin.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(stackmin.peek()&gt;node)&#123;</span><br><span class="line">                stackmin.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stackmin.push(stackmin.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        stackmin.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackmin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/04/27/%E5%89%91%E6%8C%87offer-item20-%E5%B8%A6min%E5%87%BD%E6%95%B0%E7%9A%84stack%E6%A0%88/" data-id="ck9ifiw550001zhtdfgy43tur" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer-item19-顺时针输出数组" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/04/27/%E5%89%91%E6%8C%87offer-item19-%E9%A1%BA%E6%97%B6%E9%92%88%E8%BE%93%E5%87%BA%E6%95%B0%E7%BB%84/">剑指offer系列----item19 顺时针输出数组</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/27/%E5%89%91%E6%8C%87offer-item19-%E9%A1%BA%E6%97%B6%E9%92%88%E8%BE%93%E5%87%BA%E6%95%B0%E7%BB%84/" class="article-date">
  <time datetime="2020-04-27T11:58:49.000Z" itemprop="datePublished">2020-04-27</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>顺时针打印一个二维数组</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>总的来说，这种题目思路很多。譬如就直接按照顺时针的规则进行输出即可，按照上、右、下、左的顺序。只不过每次输出一个方向之后，需要及时修改边界值，也就是去掉已经输出的那一部分。还有一种就是滚动数组，永远输出数组的第一行，不过要让数组不停的顺时针滚动。两种时间复杂度都不低，这里只给出第一种解法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/大致思路就是维护四个边界变量，分别对应着矩阵的上、右、下、左边。然后再将边界按照规则递减逐渐缩小即可。</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> width = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> depth = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> size = width*depth;</span><br><span class="line">        <span class="keyword">int</span> mini = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minj=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        loop:<span class="keyword">while</span> (list.size()&lt;size)&#123;</span><br><span class="line">            <span class="comment">//上边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=minj;j&lt;width;j++)&#123;</span><br><span class="line">                list.add(matrix[mini][j]);</span><br><span class="line">                <span class="keyword">if</span>(list.size()==size)&#123;</span><br><span class="line">                    <span class="keyword">break</span> loop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mini++;</span><br><span class="line">            <span class="comment">//右边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=mini;i&lt;depth;i++)&#123;</span><br><span class="line">                list.add(matrix[i][width-<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(list.size()==size)&#123;</span><br><span class="line">                    <span class="keyword">break</span> loop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            width—;</span><br><span class="line">            <span class="comment">//底边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=width-<span class="number">1</span>;j&gt;=minj;j--)&#123;</span><br><span class="line">                list.add(matrix[depth-<span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span>(list.size()==size)&#123;</span><br><span class="line">                    <span class="keyword">break</span> loop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth—;</span><br><span class="line">            <span class="comment">//左边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=depth-<span class="number">1</span>;i&gt;=mini;i--)&#123;</span><br><span class="line">                list.add(matrix[i][minj]);</span><br><span class="line">                <span class="keyword">if</span>(list.size()==size)&#123;</span><br><span class="line">                    <span class="keyword">break</span> loop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minj++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/04/27/%E5%89%91%E6%8C%87offer-item19-%E9%A1%BA%E6%97%B6%E9%92%88%E8%BE%93%E5%87%BA%E6%95%B0%E7%BB%84/" data-id="ck9ifhhj20000zhtdadisdoen" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer-item18-二叉树的镜像" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/04/26/%E5%89%91%E6%8C%87offer-item18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/">剑指offer系列----item18 二叉树的镜像</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/26/%E5%89%91%E6%8C%87offer-item18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/" class="article-date">
  <time datetime="2020-04-26T13:04:05.000Z" itemprop="datePublished">2020-04-26</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>输入一个二叉树，输出其二叉树的镜像。<br>注：镜像为二叉树的所有左右节点交换。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树的镜像这种题目在面试中经常会被考到，划重点啦！！！这种题目经典的思路有两种。其一是传统递归；第二种就是非递归解法。</p>
<h3 id="方法一-传统递归"><a href="#方法一-传统递归" class="headerlink" title="方法一 传统递归"></a>方法一 传统递归</h3><p>递归法没有什么太好说的，既然是左右两个节点交换，那么就是所见即所得，利用递归实现交换就完事儿了。代码见下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right=temp;</span><br><span class="line">    Mirror(root.right);</span><br><span class="line">    Mirror(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二-利用BFS非递归实现"><a href="#方法二-利用BFS非递归实现" class="headerlink" title="方法二 利用BFS非递归实现"></a>方法二 利用BFS非递归实现</h3><p>在二叉树遍历中，BFS广度优先遍历是一种非常实用的遍历方式。它将二叉树分为一层又一层，那么涉及到二叉树分层操作的题目几乎都可以用BFS来解决一二。每层遍历，然后将每个节点的左右节点交换，从而实现二叉树的镜像。具体代码见下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        TreeNode curr,temp;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            curr = queue.remove();</span><br><span class="line">            temp = curr.left;</span><br><span class="line">            curr.left = curr.right;</span><br><span class="line">            curr.right = temp;</span><br><span class="line">            <span class="keyword">if</span>(curr.left!=<span class="keyword">null</span>)queue.add(curr.left);</span><br><span class="line">            <span class="keyword">if</span>(curr.right!=<span class="keyword">null</span>)queue.add(curr.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归这种方法和栈、队列这两种数据结构，在二叉树的遍历以及很多操作中应用广泛。</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/04/26/%E5%89%91%E6%8C%87offer-item18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/" data-id="ck9h2dldz0003ertd7yh697dp" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer-item17-判断一棵树是不是另外一棵树的子结构" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/04/26/%E5%89%91%E6%8C%87offer-item17-%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%A6%E5%A4%96%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/">剑指offer系列----item17 判断一棵树是不是另外一棵树的子结构</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/26/%E5%89%91%E6%8C%87offer-item17-%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%A6%E5%A4%96%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-04-26T13:02:54.000Z" itemprop="datePublished">2020-04-26</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<p><em>题干：</em><br>判断一棵树是不是另一棵树的子结构</p>
<p><strong><em>思路：</em></strong></p>
<p>这道题值得注意的就是区分清楚什么是子树，什么是子结构。</p>
<h2 id="子树："><a href="#子树：" class="headerlink" title="子树："></a>子树：</h2><p>是只要包含了一个结点，就得包含这个结点下的所有节点。</p>
<h2 id="子结构："><a href="#子结构：" class="headerlink" title="子结构："></a>子结构：</h2><p>包含了一个结点，可以只取左子树或者右子树，或者都不取。也就是说，单单一个节点都可以是一个子结构。</p>
<h2 id="具体代码如下："><a href="#具体代码如下：" class="headerlink" title="具体代码如下："></a>具体代码如下：</h2><p><strong><em>判断一棵树是不是另外一棵树的子结构：</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span> || root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> judge(root1,root2) || judge(root1.left,root2) || judge(root1.right,root2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">       <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1.val!=root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> judge(root1.left,root2) || judge(root1.right,root2);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> judge(root1.left, root2.left) &amp;&amp; judge(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>判断一棵树是不是另外一棵树的子树：</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span> || root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//空树没有任何一个子树，空树也不是任何一个树的子树</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> judge(root1,root2) || judge(root1.left,root2) || judge(root1.right,root2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//root2所有节点已经判断完毕，是子树</span></span><br><span class="line">        &#125; </span><br><span class="line">       <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//root1的所有节点已经判断完毕，不是子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1.val!=root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//因为子树是要从这个节点到叶子节点的所有节点都相同才可以</span></span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> judge(root1.left, root2.left) &amp;&amp; judge(root1.right, root2.right);<span class="comment">//完成了上面的判断，继续进行树的下一层判断。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这些细节一定要分清楚了！！！</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/04/26/%E5%89%91%E6%8C%87offer-item17-%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%A6%E5%A4%96%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/" data-id="ck9h2c2o30002ertddydu9vqa" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-无关痛痒的一些闲话" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/04/25/%E6%97%A0%E5%85%B3%E7%97%9B%E7%97%92%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%B2%E8%AF%9D/">无关痛痒的一些闲话</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/25/%E6%97%A0%E5%85%B3%E7%97%9B%E7%97%92%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%B2%E8%AF%9D/" class="article-date">
  <time datetime="2020-04-25T14:57:23.000Z" itemprop="datePublished">2020-04-25</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>这是一个被疫情打乱的2020</p>
<p>以前全部的理所应当在现在都有些勉强</p>
<p>最近发现可能生活真的需要一点的不一样</p>
<p>每天三点一线  为了money</p>
<p>真的快乐么</p>
<p>还是说人生而就是为了赎罪</p>
<p>我是一个很乐观的人</p>
<p>但是乐观不代表没有悲观</p>
<p>我会沮丧</p>
<p>我会失望</p>
<p>我在期待</p>
<p>我也会害怕</p>
<p>但是似乎每一个明天的我都会逐渐的释怀</p>
<p>逐渐的忘记</p>
<p>希望</p>
<p>我能一直这样</p>
<p>平安喜乐</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/04/25/%E6%97%A0%E5%85%B3%E7%97%9B%E7%97%92%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%B2%E8%AF%9D/" data-id="ck9fqz2iq0001ertdbuqrg8qe" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer系列-item16-合并排序链表" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/04/23/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item16-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/">剑指offer系列----item16 合并排序链表</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/23/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item16-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/" class="article-date">
  <time datetime="2020-04-23T12:29:24.000Z" itemprop="datePublished">2020-04-23</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h1 id="题干："><a href="#题干：" class="headerlink" title="题干："></a><strong><em>题干：</em></strong></h1><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong><em>思路：</em></strong></h1><p>这道题的方法有很多，首先大类分为两种：<strong><em>1.使用额外的空间；2.使用递归在原先链表中进行操作。</em></strong></p>
<h2 id="1-使用额外的空间"><a href="#1-使用额外的空间" class="headerlink" title="1.使用额外的空间"></a>1.使用额外的空间</h2><p>在这种思路中，可以两种额外空间的方式。第一种采用集合将两个链表中的val全部取出，然后隔离链表进行排序，之后再赋值给原先链表或者再新建一个链表。这种方法思路出气简单，新手一般会采用。但是空间和时间复杂度都很大。具体代码加下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ListNode temp1 = list1;</span><br><span class="line">    ListNode temp2 = list2;</span><br><span class="line">    ListNode temp3 = list1;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (list1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(list1.val);</span><br><span class="line">        list1=list1.next;</span><br><span class="line">        flag++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (list2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(list2.val);</span><br><span class="line">        list2=list2.next;</span><br><span class="line">        flag1++;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;flag;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp1.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        temp1.val=list.get(i);</span><br><span class="line">        temp1=temp1.next;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp1.val=list.get(i);</span><br><span class="line">            temp1.next=temp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=flag;i&lt;flag1+flag;i++)&#123;</span><br><span class="line">        temp2.val=list.get(i);</span><br><span class="line">        temp2=temp2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么第二种就是新建一个ListNode，然后去比较list1和list2，哪一个小一些就先加在这个新建的ListNode后面。代码见下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode c = newNode;</span><br><span class="line">        <span class="keyword">while</span> (list1!=<span class="keyword">null</span> &amp;&amp; list2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">                newNode.next = list1;</span><br><span class="line">                list1=list1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                newNode.next = list2;</span><br><span class="line">                list2=list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            newNode=newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            newNode.next = list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            newNode.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-使用递归在原先链表中进行操作。"><a href="#2-使用递归在原先链表中进行操作。" class="headerlink" title="2.使用递归在原先链表中进行操作。"></a>2.使用递归在原先链表中进行操作。</h2><p>递归操作简单明了，直接给出代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">                list1.next = Merge(list1.next,list2);</span><br><span class="line">                <span class="keyword">return</span> list1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                list2.next = Merge(list1,list2.next);</span><br><span class="line">                <span class="keyword">return</span> list2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总而言之，三种方法都可解决此问题！</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/04/23/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item16-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/" data-id="ck9cqtgau0000ertdgulr8xqi" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer系列-item15-翻转链表" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/04/23/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item15-%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/">剑指offer系列----item15 翻转链表</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/23/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item15-%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/" class="article-date">
  <time datetime="2020-04-23T08:01:01.000Z" itemprop="datePublished">2020-04-23</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<p><strong><em>题干：</em></strong><br>将一个链表进行翻转。</p>
<p><strong><em>思路：</em></strong><br>这道题的思路明显，有两种典型思路解决。<br><strong>思路一</strong>：”假“翻转。所谓假翻转的意思就是，仅仅只翻转链表节点内部的数值，不翻转节点本身。具体而言，将链表内部的数值用集合”盛“出来，然后对这个链表进行翻转操作，最后再利用这个集合为链表重新赋值。值得一提的是，这种方法，链表节点之间的相互引用关系并未发生改变，变化的仅仅是节点内部的值。</p>
<p><strong>思路二</strong>：”真“翻转。所谓真翻转是针对”假“翻转而言的，这中方法会利用中间节点真正的实现相邻节点的顺序翻转。效率更高，也是这道题目我推荐的解法。</p>
<p>下面分别给出两种解法的具体代码：</p>
<p>way1:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只换值，不换前后映射关系，即不换前后节点的引用指向。</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ListNode head1= head;</span><br><span class="line">    ListNode cc=head;</span><br><span class="line">    <span class="keyword">while</span> (head1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(head1.val);</span><br><span class="line">        head1=head1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(list);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        head.val=list.get(i);</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>way2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;<span class="comment">//这里是把引用指向修改，本身val数值不变，并非把整个节点修改，但是仍然实现了反转的效果</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>可以将pre与curr看成是一组翻转工具，不停的执行相邻两个链表节点的翻转操作。</em></strong></p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/04/23/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item15-%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/" data-id="ck9ch8arn00025otd8kzo03ln" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
    </article>
    
  
    
      <nav class="page-nav">
        <a class="extend prev" rel="prev" href="/">Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next</a>
      </nav>
    
  </section>
</div>

  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 Hogwarts library</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Hogwarts library"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/ocean.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"live2d-widget-model-tororo"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>