<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="为保证浏览效果，请尽量使用Chrome">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    Hogwarts library</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay=""
             poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">Hogwarts library</a></h1>
      <p>欢迎来到Siriustjq的世界</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="Hogwarts library"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
    <article class="articles">
      
      <h1 class="page-type-title"></h1>
      
        
          <article id="post-剑指offer系列-item32-把数组排成最小数" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E6%95%B0/">剑指offer系列----item32 把数组排成最小数</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E6%95%B0/" class="article-date">
  <time datetime="2020-05-04T08:49:46.000Z" itemprop="datePublished">2020-05-04</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>把数组变成String的list，然后两个两个比较，因为s1+s2的长度和s2+s1的长度是一致的，所以如果s1+s2与s2+s1的大小判断只需要判从首个字符开始即可（所以调用的String类的compareTo方法），如果s1+s2&gt;s2+s1,OK，那么说明s2应该在s1的前面，具体代码见下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cc:numbers)&#123;</span><br><span class="line">            list.add(String.valueOf(cc));</span><br><span class="line">        &#125;</span><br><span class="line">        list.sort((S1,S2) -&gt; (S1+S2).compareTo(S2+S1));<span class="comment">//核心lambda表达式，具体可以去参考我的另外一篇博客</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(String ll:list)&#123;</span><br><span class="line">            sb.append(ll);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于Lamdba表达式，可以看我的另外一篇博客：<a href="https://blog.csdn.net/weixin_38107316/article/details/105918971" target="_blank" rel="noopener">Lambda表达式</a></p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E6%95%B0/" data-id="ck9s8te79000bb5tdclztehqn" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer系列-item31-从1到n个整数中，包含1的个数有几个？" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item31-%E4%BB%8E1%E5%88%B0n%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%AD%EF%BC%8C%E5%8C%85%E5%90%AB1%E7%9A%84%E4%B8%AA%E6%95%B0%E6%9C%89%E5%87%A0%E4%B8%AA%EF%BC%9F/">剑指offer系列----item31 从1到n个整数中，包含1的个数有几个？</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item31-%E4%BB%8E1%E5%88%B0n%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%AD%EF%BC%8C%E5%8C%85%E5%90%AB1%E7%9A%84%E4%B8%AA%E6%95%B0%E6%9C%89%E5%87%A0%E4%B8%AA%EF%BC%9F/" class="article-date">
  <time datetime="2020-05-04T08:49:01.000Z" itemprop="datePublished">2020-05-04</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>如题所示，从1到n个整数中，包含1的个数有几个？</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这道题最最直接的思路应该是数学解答方法，即利用纯数学归纳总结出结果。但是有点儿复杂，且容易错。本文中采用递归法，对问题进行解答。首先给出代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> dfs(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String numStr = String.valueOf(n);<span class="comment">//利用字符串将数字剥离，利用数学方法还需循环</span></span><br><span class="line">        <span class="keyword">int</span> high = numStr.charAt(<span class="number">0</span>) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> pow = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, numStr.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> last = n - high * pow;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (high == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 最高位是1，如1234, 此时pow = 1000,那么结果由以下三部分构成：</span></span><br><span class="line">            <span class="comment">// (1) dfs(pow - 1)代表[0,999]中1的个数;</span></span><br><span class="line">            <span class="comment">// (2) dfs(last)代表234中1出现的个数;</span></span><br><span class="line">            <span class="comment">// (3) last+1代表固定高位是1有多少种情况。</span></span><br><span class="line">            <span class="keyword">return</span> dfs(pow - <span class="number">1</span>) + dfs(last) + last + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 最高位不为1，如2234，那么结果也分成以下三部分构成：</span></span><br><span class="line">            <span class="comment">// (1) pow代表固定高位1，有多少种情况;</span></span><br><span class="line">            <span class="comment">// (2) high * dfs(pow - 1)代表999以内和1999以内低三位1出现的个数;</span></span><br><span class="line">            <span class="comment">// (3) dfs(last)同上。</span></span><br><span class="line">            <span class="keyword">return</span> pow + high * dfs(pow - <span class="number">1</span>) + dfs(last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>明显看到，这种解法将问题分成了两大核心模块：<br>1.首位为1；2.首位非1。然后再进一步解答~</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item31-%E4%BB%8E1%E5%88%B0n%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%AD%EF%BC%8C%E5%8C%85%E5%90%AB1%E7%9A%84%E4%B8%AA%E6%95%B0%E6%9C%89%E5%87%A0%E4%B8%AA%EF%BC%9F/" data-id="ck9s8ser8000ab5tdb69ygj9r" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer系列-item30-一个数组的最大连续子序列之和" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item30-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E4%B9%8B%E5%92%8C/">剑指offer系列----item30 一个数组的最大连续子序列之和</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item30-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E4%B9%8B%E5%92%8C/" class="article-date">
  <time datetime="2020-05-04T08:48:18.000Z" itemprop="datePublished">2020-05-04</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>输入一个数组，输出这个数组的最大连续子序列之和。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>思路有2，第一种传统的动态规划思路。这种可以划分为多个子问题叠加的题目利用动态规划解决是最最经典的思路。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[]=<span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    dp[<span class="number">0</span>]= array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max=array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        dp[i]=Math.max(dp[i-<span class="number">1</span>]+array[i],array[i]);<span class="comment">//转移方程</span></span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;max)&#123;</span><br><span class="line">            max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，可以利用贪心算法进行求解：<br>数组的每个数字挨个相加，但是需要注意规则：<br>当num小于等于0时，将num改为当前数组nums[i]的值；<br>当num大于0时，num=num+nums[i]的值；<br>不断对比max和num的值，返回最大值max。<br>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                num = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                num += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;num)&#123;</span><br><span class="line">                max=num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item30-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E4%B9%8B%E5%92%8C/" data-id="ck9s8rhl60009b5td1516eut3" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer系列-item29-一个数组中最小的K个数" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item29-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/">剑指offer系列----item29 一个数组中最小的K个数</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item29-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/" class="article-date">
  <time datetime="2020-05-04T08:46:56.000Z" itemprop="datePublished">2020-05-04</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>如题所示，输出一个数组中最小的k个数。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这道题思路其实很简单，核心就是去排序，所以这道题实际考察的是排序的求解思路。具体见以下三种做法：</p>
<p>利用封装的sort函数（懒人法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(input);</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(k&gt;input.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        list.add(input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用快排切分的思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个参数表示我们要找的是下标为k-1的数</span></span><br><span class="line">        <span class="keyword">return</span> quickSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] quickSearch(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(nums, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j &gt; k? quickSearch(nums, lo, j - <span class="number">1</span>, k): quickSearch(nums, j + <span class="number">1</span>, hi, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[lo];</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= hi &amp;&amp; nums[i] &lt; v);</span><br><span class="line">            <span class="keyword">while</span> (--j &gt;= lo &amp;&amp; nums[j] &gt; v);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t = nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[lo] = nums[j];</span><br><span class="line">        nums[j] = v;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用堆排序的思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：</span></span><br><span class="line"><span class="comment">// 1. 若目前堆的大小小于K，将当前数字放入堆中。</span></span><br><span class="line"><span class="comment">// 2. 否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；</span></span><br><span class="line"><span class="comment">//    反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认是小根堆，实现大根堆需要重写一下比较器。</span></span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k) &#123;</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; pq.peek()) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回堆中的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[pq.size()];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: pq) &#123;</span><br><span class="line">            res[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item29-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/" data-id="ck9s8pq8w0008b5tdf2lu8o74" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer系列-item28-数组中超过一半的数" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item28-%E6%95%B0%E7%BB%84%E4%B8%AD%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0/">剑指offer系列----item28 数组中超过一半的数</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item28-%E6%95%B0%E7%BB%84%E4%B8%AD%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0/" class="article-date">
  <time datetime="2020-05-04T08:45:15.000Z" itemprop="datePublished">2020-05-04</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>思路有2：<br>其一，首先对数组进行排序，然后再利用动态规划解决问题；<br>其二，直接利用摩尔投票法进行问题的解决。</p>
<p>具体解法见下：<br>way1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。</span></span><br><span class="line"><span class="comment">由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：因为只有一个数字出现的次数大于数组的一半，那么就可以直接将整个数组中出现最多的这个数给找出来，</span></span><br><span class="line"><span class="comment">如出现的次数大于数组长度的一半，返回该数字。反之，返回0即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">具体思路：先排序数组，然后利用动态规划的思想</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">item26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];<span class="comment">//dp[i]为插入第i个数字之后第i个数字出现的频率；</span></span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        dp[<span class="number">0</span>]= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxindex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)y&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==array[i-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;sum)&#123;</span><br><span class="line">                sum=dp[i];</span><br><span class="line">                maxindex=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;array.length/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//System.out.println(sum);</span></span><br><span class="line">            <span class="keyword">return</span> array[maxindex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>way2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, votes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(votes == <span class="number">0</span>) x = num;</span><br><span class="line">            votes += num == x ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种思想应该着重记一下，蛮有趣的~ 与君共勉！</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/05/04/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97-item28-%E6%95%B0%E7%BB%84%E4%B8%AD%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0/" data-id="ck9s8nje30007b5tdh5x840da" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-看懂Lambda表达式这一篇就够了" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/05/04/%E7%9C%8B%E6%87%82Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/">看懂Lambda表达式这一篇就够了</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/05/04/%E7%9C%8B%E6%87%82Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/" class="article-date">
  <time datetime="2020-05-04T08:41:33.000Z" itemprop="datePublished">2020-05-04</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author：Siriustjq</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>关于lambda表达式，网上的资料不少，但是仔细看一看就会发现，写的良莠不齐，且大部分博文的表达较差，词不达意，所以这里自己进行一次总结，方便日后复习。</p>
<h2 id="什么是Lambda表达式？"><a href="#什么是Lambda表达式？" class="headerlink" title="什么是Lambda表达式？"></a>什么是Lambda表达式？</h2><p>lambda表达式，是Java作为面向对象的编程语言在函数式编程方面的一些拓展和优点合并。<br><strong>Lambda 允许把函数（行为）作为一个方法的参数（函数作为参数传递进方法中）</strong>。在lambda表达式子出现之前，实现这种功能大部分时候是在依赖匿名内部类。而lambda表达式利用lambda操作符“-&gt;”实现了很多以前必须要匿名内部类才能实现的功能，并且极大地简化了代码的结构和复杂度。</p>
<p>lambda操作符将整个lambda表达式分为了两部分，即箭头的左右：<br><strong>箭头左边表示lambda表达式的参数列表；<br>箭头右边则具体表示lambda表达式所要执行的功能，或者说是函数体。</strong><br>这里提前说明，lambda表达式是离不开接口的。见下面这个例子：</p>
<p>多线程大家一定不陌生，创建一个线程无非有两种方法（不考虑线程池）：1.继承Thread类；2.实现Runable接口。实际的生产实践中自然是使用第二种方法更多，因为一个类只能有一个父类，但是却可以实现多个接口。那么下面使用第二种方法新建一个线程并且采用匿名内部类的方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"传统匿名内部类的实现方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，代码量还是蛮大的，当然比去实现一个Runable接口要简洁的多得多，如果想进一步简洁代码呢？那就用到了lambda表达式了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">"lambda表达式的实现方法"</span>)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test();</span><br><span class="line">test1();</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果如下：</span></span><br><span class="line">传统匿名内部类的实现方法</span><br><span class="line">lambda表达式的实现方法</span><br></pre></td></tr></table></figure>
<p>可以看到短短一条语句就完全替换了之前的匿名内部类，效率确实有一些高~<br>通过这个例子，能更好的理解lambda表达式离不开接口。通过上面例子可以大致看出lambda表达式的一些端倪了，让我们来总结一下：<br><strong>-&gt;lambda表达式的左边为形参，注意形参一定要和lambda表达式所关联的接口的抽象方法的形参保持一致，不然会报错！</strong>这里很多博文的总结一直有问题，所以重申一下。<br>-&gt;lambda表达式的右边为方法的重写，谁的方法？自然也就是lambda表达式所关联接口的方法的重写，在这里你可以为所欲为的调用其他类的方法进行重写，<strong>但是一定要注意返回值务必要和原生的接口方法的返回值一致</strong>。针对以上两点，有一句很绕的官方解释：<strong>“实现抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致”</strong>。建议还是按照我的解释来理解容易一些。</p>
<p>一个例子可能还是太空洞了，请看下面这个例子，让集合list按照我们所制定的规则进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.sort((s1,s2)-&gt;(s1+s2).compareTo(s2+s1));</span><br></pre></td></tr></table></figure>
<p>乍一看这一句会云里雾里，我们来看看list集合的sort方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);<span class="comment">//调用的是Arrays.sort()方法</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明显调用的是Arrays.sort()方法，我们继续深入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sort(a, fromIndex, toIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, fromIndex, toIndex, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, fromIndex, toIndex, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续进入legacyMergeSort方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">legacyMergeSort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    T[] aux = copyOfRange(a, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">if</span> (c==<span class="keyword">null</span>)</span><br><span class="line">        mergeSort(aux, a, fromIndex, toIndex, -fromIndex);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mergeSort(aux, a, fromIndex, toIndex, -fromIndex, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续深入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Object[] src,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Object[] dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> off,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Comparator c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = high - low;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insertion sort on smallest arrays</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;high; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;low &amp;&amp; c.compare(dest[j-<span class="number">1</span>], dest[j])&gt;<span class="number">0</span>; j—)<span class="comment">//终于逮到你了</span></span><br><span class="line">                swap(dest, j, j-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively sort halves of dest into src</span></span><br><span class="line">    <span class="keyword">int</span> destLow  = low;</span><br><span class="line">    <span class="keyword">int</span> destHigh = high;</span><br><span class="line">    low  += off;</span><br><span class="line">    high += off;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(dest, src, low, mid, -off, c);</span><br><span class="line">    mergeSort(dest, src, mid, high, -off, c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If list is already sorted, just copy from src to dest.  This is an</span></span><br><span class="line">    <span class="comment">// optimization that results in faster sorts for nearly ordered lists.</span></span><br><span class="line">    <span class="keyword">if</span> (c.compare(src[mid-<span class="number">1</span>], src[mid]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">       System.arraycopy(src, low, dest, destLow, length);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge sorted halves (now in src) into dest</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= <span class="number">0</span>)</span><br><span class="line">            dest[i] = src[p++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dest[i] = src[q++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于我们发现在这里会调用Comparator内的方法compare方法，而我们已经将其按照我们所需要实现的逻辑进行了重写，也就是在lambda表达式的右边的式子：(s1+s2).compareTo(s2+s1)；<br>在理解了上面lambda表达式的逻辑之后，马上我们可以再利用传统的匿名内部类对上述代码重构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list.sort(<span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String)o1+(String)o2).compareTo((String)o2+(String)o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>二者实现的功能完全一致，均能让集合list按照我们所指定的逻辑进行排序。</p>
<h2 id="写在最后："><a href="#写在最后：" class="headerlink" title="写在最后："></a>写在最后：</h2><p>一句话总结lambda表达式———它可以让我们更简便更直接的去实现一个接口，并重写其方法。</p>
<h2 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h2><p>本篇博客主要是以分析lambda的含义与典型作用方法为主，具体的表达式语法可参考：<a href="https://www.runoob.com/java/java8-lambda-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/java/java8-lambda-expressions.html</a><br> <a href="https://www.cnblogs.com/nnxud/p/9827704.html" target="_blank" rel="noopener">https://www.cnblogs.com/nnxud/p/9827704.html</a><br> 以上两篇博客说的都比较详细了，这里记录一下也方便自己日后及时查看复习。</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/05/04/%E7%9C%8B%E6%87%82Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/" data-id="ck9s8iq2r0006b5tdbzcx0t8o" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer-item27-字符串的排列（究极无敌多种java回溯-剪枝做法）" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/04/29/%E5%89%91%E6%8C%87offer-item27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%88%E7%A9%B6%E6%9E%81%E6%97%A0%E6%95%8C%E5%A4%9A%E7%A7%8Djava%E5%9B%9E%E6%BA%AF-%E5%89%AA%E6%9E%9D%E5%81%9A%E6%B3%95%EF%BC%89/">剑指offer系列----item27 字符串的排列（究极无敌多种java回溯+剪枝做法）</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/29/%E5%89%91%E6%8C%87offer-item27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%88%E7%A9%B6%E6%9E%81%E6%97%A0%E6%95%8C%E5%A4%9A%E7%A7%8Djava%E5%9B%9E%E6%BA%AF-%E5%89%AA%E6%9E%9D%E5%81%9A%E6%B3%95%EF%BC%89/" class="article-date">
  <time datetime="2020-04-29T11:29:43.000Z" itemprop="datePublished">2020-04-29</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这道题思路明显，全排列问题的解决核心就是利用回溯法。只不过这道题全排列的结果可能会包含重复的值，所以还需要应用剪枝来去重，所以下面的几种解法都是利用回溯法思想，只不过剪枝的操作略有不同。</p>
<p>具体的多种解法见下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> flag[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[str.length()];</span><br><span class="line">        String[] strings = str.split(<span class="string">""</span>);</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">        quanpailie(strings,flag,<span class="number">0</span>,strings.length,list,stack);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            String temp = list.get(i).toString();</span><br><span class="line">            String[] temp1 = temp.substring(<span class="number">1</span>,temp.length()-<span class="number">1</span>).split(<span class="string">", "</span>);</span><br><span class="line">            System.out.println(temp1.length);</span><br><span class="line">            StringBuffer SB = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">for</span>(String ss:temp1)&#123;</span><br><span class="line">                SB.append(ss);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!list1.contains(SB.toString()))&#123;</span><br><span class="line">                <span class="comment">//System.out.println(SB.toString().length());</span></span><br><span class="line">                list1.add(SB.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quanpailie</span><span class="params">(String[] str, <span class="keyword">boolean</span>[] flag, <span class="keyword">int</span> cursize, <span class="keyword">int</span> len, List&lt;List&lt;String&gt;&gt; list, Stack&lt;String&gt; stack)</span></span>&#123;<span class="comment">//这里的回溯算法入口的参数过多了，可以设置为私有变量private，从而不需要传入这么多的入参。</span></span><br><span class="line">        <span class="keyword">if</span>(cursize==len)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">                    stack.push(str[i]);</span><br><span class="line">                    flag[i]=<span class="keyword">true</span>;</span><br><span class="line">                    quanpailie(str,flag,cursize+<span class="number">1</span>,len,list,stack);</span><br><span class="line">                    flag[i]=<span class="keyword">false</span>;<span class="comment">//状态重置</span></span><br><span class="line">                    stack.pop();<span class="comment">//状态重置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以明显看出，上面这个代码非常的臃肿繁杂，简化一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span>  ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">if</span>(str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//boolean flag[]=new boolean[str.length()];</span></span><br><span class="line">    String[] strings = str.split(<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//Stack&lt;String&gt; stack = new Stack&lt;String&gt;();</span></span><br><span class="line">    quanpailie(strings,<span class="number">0</span>,strings.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        String temp = list.get(i).toString();</span><br><span class="line">        String[] temp1 = temp.substring(<span class="number">1</span>,temp.length()-<span class="number">1</span>).split(<span class="string">", "</span>);</span><br><span class="line">        System.out.println(temp1.length);</span><br><span class="line">        StringBuffer SB = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(String ss:temp1)&#123;</span><br><span class="line">            SB.append(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!list1.contains(SB.toString()))&#123;</span><br><span class="line">            <span class="comment">//System.out.println(SB.toString().length());</span></span><br><span class="line">            list1.add(SB.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quanpailie</span><span class="params">(String[] str, <span class="keyword">int</span> cursize, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cursize==len)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(stack));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">                stack.push(str[i]);</span><br><span class="line">                flag[i]=<span class="keyword">true</span>;</span><br><span class="line">                quanpailie(str,cursize+<span class="number">1</span>,len);</span><br><span class="line">                flag[i]=<span class="keyword">false</span>;<span class="comment">//状态重置</span></span><br><span class="line">                stack.pop();<span class="comment">//状态重置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] strings = str.split(<span class="string">""</span>);</span><br><span class="line">    quanpailie(strings,<span class="number">0</span>,strings.length);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最核心的就是回溯函数（本质就是递归）以及状态的重置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quanpailie</span><span class="params">(String[] str, <span class="keyword">int</span> cursize, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cursize==len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list.contains(sb.toString()))&#123;<span class="comment">//去重（剪枝），时间复杂度过高，在leetcode会超时</span></span><br><span class="line">            list.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">                sb.append(str[i]);</span><br><span class="line">                flag[i]=<span class="keyword">true</span>;</span><br><span class="line">                quanpailie(str,cursize+<span class="number">1</span>,len);</span><br><span class="line">                flag[i]=<span class="keyword">false</span>;<span class="comment">//状态重置</span></span><br><span class="line">                sb.deleteCharAt(sb.length()-<span class="number">1</span>);<span class="comment">//状态重置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对上面剪枝的时间复杂度过高的问题，继续优化如下，利用TreeSet完成去重操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeSet&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();<span class="comment">//利用TreeSet执行去重效果，因为其本身就不支持重复的元素</span></span><br><span class="line">    <span class="keyword">private</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        String[] strings = s.split(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> strings;</span><br><span class="line">        &#125;</span><br><span class="line">        quanpailie(strings,<span class="number">0</span>,strings.length);</span><br><span class="line">        String [] res = <span class="keyword">new</span> String[set.size()];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s1:set)&#123;</span><br><span class="line">            res[i]=s1;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quanpailie</span><span class="params">(String[] strings, <span class="keyword">int</span> current, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current==len)&#123;</span><br><span class="line">            set.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">                    sb.append(strings[i]);</span><br><span class="line">                    flag[i]=<span class="keyword">true</span>;</span><br><span class="line">                    quanpailie(strings,current+<span class="number">1</span>,len);</span><br><span class="line">                    flag[i]=<span class="keyword">false</span>;</span><br><span class="line">                    sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以继续优化，在回溯的期间完成剪枝操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面两种去重操作的时间复杂度都有一些大，这里先将数组排序，然后在添加的时候判断，时间复杂度低一些</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        String[] strings = s.split(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">char</span> [] c = s.toCharArray();</span><br><span class="line">        Arrays.sort(c);<span class="comment">//这里的排序操作是为了后面的去重</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> strings;</span><br><span class="line">        &#125;</span><br><span class="line">        quanpailie(c,<span class="number">0</span>,c.length);</span><br><span class="line">        String [] res = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s1:list)&#123;</span><br><span class="line">            res[i]=s1;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quanpailie</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> current, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current==len)&#123;</span><br><span class="line">            list.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; c[i]==c[i-<span class="number">1</span>] &amp;&amp; !flag[i-<span class="number">1</span>])&#123;<span class="comment">//去重操作（剪枝操作）</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sb.append(c[i]);</span><br><span class="line">                    flag[i]=<span class="keyword">true</span>;</span><br><span class="line">                    quanpailie(c,current+<span class="number">1</span>,len);</span><br><span class="line">                    flag[i]=<span class="keyword">false</span>;</span><br><span class="line">                    sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/04/29/%E5%89%91%E6%8C%87offer-item27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%88%E7%A9%B6%E6%9E%81%E6%97%A0%E6%95%8C%E5%A4%9A%E7%A7%8Djava%E5%9B%9E%E6%BA%AF-%E5%89%AA%E6%9E%9D%E5%81%9A%E6%B3%95%EF%BC%89/" data-id="ck9l9bswv0005b5td5tom704v" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer-item26-二叉搜索树与双向链表" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/04/29/%E5%89%91%E6%8C%87offer-item26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/">剑指offer系列----item26 二叉搜索树与双向链表</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/29/%E5%89%91%E6%8C%87offer-item26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" class="article-date">
  <time datetime="2020-04-29T11:28:43.000Z" itemprop="datePublished">2020-04-29</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>大致思路，二叉搜索树的中序遍历应该就是有序的，我认为这道题的核心就是二叉树的中序遍历方法。返回到是双向链表，却要求不能有新的节点，那么说明肯定不能创建一个链表了，只能修改指针！先把树的node通过中序遍历形成有序的list，再修改list内部Treenode的指针，前一个list节点的右子树指向下一个节点，后一个list节点的左子树则指向前一个节点。</p>
<p>具体解法见下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">item24</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> converindex(LROOTR(pRootOfTree,list));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先中序遍历此二叉树，利用递归即可</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ArrayList&lt;TreeNode&gt; <span class="title">LROOTR</span><span class="params">(TreeNode root, ArrayList&lt;TreeNode&gt;list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            LROOTR(root.left,list);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(root);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            LROOTR(root.right,list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始改变原二叉排序树的指针顺序，改为双向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">converindex</span><span class="params">(ArrayList&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            list.get(i).right = list.get(i+<span class="number">1</span>);</span><br><span class="line">            list.get(i+<span class="number">1</span>).left = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/04/29/%E5%89%91%E6%8C%87offer-item26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" data-id="ck9l9aium0004b5td2mas1wyc" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer-item25-复制复杂链表" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/04/29/%E5%89%91%E6%8C%87offer-item25-%E5%A4%8D%E5%88%B6%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8/">剑指offer系列----item25 复制复杂链表</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/29/%E5%89%91%E6%8C%87offer-item25-%E5%A4%8D%E5%88%B6%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8/" class="article-date">
  <time datetime="2020-04-29T11:28:01.000Z" itemprop="datePublished">2020-04-29</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点：注意此处这个任意一个节点也是属于这个链表中的，这句话很重要！），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这道题关键就是有两点：<br>1.绝对不能直接将引用指向原头节点：<br> RandomListNode node = pHead;<br> return node;<br>上面这样操作，会直接导致输出为空；<br>2.另外一个指针是指向任意节点，注意任意二字！！！甚至可能是指向自己！！！！</p>
<p>所以，这道题的思想核心就是利用HashMap完成新旧节点的映射关系，新建两个引用，一个负责插入key、value的映射对；而另外一个引用则是用来添加next、和random。具体见下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HashMap&lt;RandomListNode,RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        RandomListNode p1 = pHead;</span><br><span class="line">        RandomListNode p2 = pHead;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(p1,<span class="keyword">new</span> RandomListNode(p1.label));</span><br><span class="line">            p1=p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p2.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                map.get(p2).next = map.get(p2.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                map.get(p2).next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(p2).random = map.get(p2.random);</span><br><span class="line">            p2=p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/04/29/%E5%89%91%E6%8C%87offer-item25-%E5%A4%8D%E5%88%B6%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8/" data-id="ck9l99mfs0003b5td4qwpg72f" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-剑指offer-item24-找出二叉树中路径之和为目标值的所有路径" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2020/04/29/%E5%89%91%E6%8C%87offer-item24-%E6%89%BE%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/">剑指offer系列----item24 找出二叉树中路径之和为目标值的所有路径</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/29/%E5%89%91%E6%8C%87offer-item24-%E6%89%BE%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/" class="article-date">
  <time datetime="2020-04-29T11:25:00.000Z" itemprop="datePublished">2020-04-29</time>
</a>
                            
                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <hr>
<p>author: Sirius tjq</p>
<h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a>题干：</h2><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。<br>    路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br>    (注意: 在返回值的list中，数组长度大的数组靠前)</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>思路有二：<br>    1.将所有的root到叶子节点的路径找出来，建成list，并用val的累加值做key，用后者list当val，再去对比与目标值到hashmap中去找相匹配的key。<br>    2.找路径的时候就加上判断，小于target才继续向下，反之直接停止。我认为本题目的根本还是二叉树的遍历(前序遍历)加一个与target的判断。因为前序遍历本身还是属于DFS的一种，是深度优先，所以适合这种找路径的题目（自上而下）。综上，这道题目的最优解应该为：DFS递归+target目标值计算。具体代码见下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">item23</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();<span class="comment">//放置所有路径</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();<span class="comment">//放置某一条路径</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target=target-root.val;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span> &amp;&amp; root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            lists.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">            <span class="comment">//因为result.add(list)是把list这个对象的引用地址添加到result了，result中的元素就会共用list，</span></span><br><span class="line">            <span class="comment">// 而list是我们用来存放当前路径的地方，是一个容器，因此我们需要复制一份之后加入result数组中</span></span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root.left,target);</span><br><span class="line">        FindPath(root.right,target);</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);<span class="comment">//就是一个容器，或者工具，盛满了当然要去除</span></span><br><span class="line">        <span class="comment">//因为当本次递归结束返回上一层的时候，我们已经遍历完这个节点的左右子树，也就是已经该树中可能存在的路径，</span></span><br><span class="line">        <span class="comment">// 再次返回上一层的时候要把这个节点除去，这样在遍历上一个节点的其他子树的时候遍历的结果才是对的</span></span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，这道题的递归思路与回溯法相似，list会涉及到状态重置或者说是状态回溯，因为一条路径找完后需要回到上一个节点继续寻找，存在一个典型的回溯过程。</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2020/04/29/%E5%89%91%E6%8C%87offer-item24-%E6%89%BE%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/" data-id="ck9l95qxy0002b5td075ddmb3" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    

                

</article>
        
    </article>
    
  
    
      <nav class="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next</a>
      </nav>
    
  </section>
</div>

  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 Hogwarts library</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Hogwarts library"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/ocean.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"live2d-widget-model-tororo"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>